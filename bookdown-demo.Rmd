--- 
title: "环境数据分析与可视化"
author: "谭巧国"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: rstudio/bookdown-demo
description: "厦门大学环境与生态学院研究生课程"
---

# 前言 {-}

本网站内容用于厦门大学环境与生态学院研究生课程“环境数据分析与可视化”的教学。内容在持续更新中。



```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# R的基础知识 {#intro}

## 科学计算器

四则运算：
```{r comment='#'}
(1 + 2 * 4)/3 - 1.3
```

指数运算：
例如，100的0.5次方：
```{r comment='#'}
100^0.5
```

对数运算：
```{r comment='#'}
log(2)
```
注意这是自然对数，与excel里的表述不一样。若以10为底，需明确标注：
```{r comment='#'}
log10(2) 
```
类似地，以2为底的对数是：
```{r}
log2(2)
```

特殊的常数：
e是自然对数的底，e=2.718..., exp(1) = e^1；用于指数函数
```{r}
exp(1)
```

pi = 3.14159...圆周率
```{r}
sin(pi/2)
```

科学计数法，6.22*10^23，注意这里e不是自然对数的底
```{r}
6.22e23
```

绝对值
```{r}
abs(-10) 

```


### 取整  


`round()`函数取整原则：**四舍六入五成双**
```{r}
round(2.3)
round(2.6)
round(2.5)
round(3.5)

floor(2.6) #向下取整
ceiling(2.3) #向上取整
trunc(2.3)#取整数部分
trunc(2.6)

```




### 保留有效数字

原则：**四舍六入五成双**
```{r}
round(pi, 2) #保留2位小数
round(pi, 3) #保留3位小数

signif(pi,2) #保留2位有效数字
signif(pi,3) #保留3位有效数字
```




### 常用运算符

符号 | 含义
-----|-------------
+    | 加
-    |减
*    |乘
/    |除
^    |乘方
%/%  |商
%%   |余数
\>   |大于
\>=  |大于等于
=    |等于
<    |小于
<=   |小于等于
==   |等于
!=   |不等于
!    |非
&    |与
\||或
~    |前者是后者的函数
<-   |向左赋值 (可读作“得到”)
->   |向右赋值 (可读作“得到”)
$    |列表索引
:    |创建序列



\newpage

### 逻辑运算  


```{r}
5 > 3
5 == 3
1:5 != 3
```


```{r}
1:5 > 2 & 1:5 <5
1:5 <= 2 | 1:5 >=4

```


>注：`1：5`的是指包含“1，2，3，4，5”这5个自然数的向量



##  变量赋值

在R语言里，用符号"**`<-`**"给变量赋值。它的功能和"**`=`**"几乎等同。但是用`<-`是一种传统，我们最好遵守。

```{r}
x1 = 12
x1

x2 <- 23
x2

y <- x1 + x2
y

x1 + x2 -> z 
z
```



##  变量取名规则  


* 变量名只能是字母、数字、点（`.`）、下划线（`_`）的组合

* 只能以字母或点开头；不能以数字、下划线开头

* 对字母大小写敏感，`a`和`A`是不同的变量
* 变量名不能含有空格：`x_1`, `x.1`都可以，但`x 1`不可以；推荐`x_1`形式的命名，理由是方便阅读，方便记忆



##  变量类型  

变量     | 含义
---------|-------------
integer  | 整数
numeric  | 实数
character| 字符
logical  | 逻辑值(`TRUE`或`FALSE`)



```{r}
class(as.integer(1.2)) #将1.2转化为整数,并查看其类型

```


```{r}

class(pi) # pi = 3.1415......
class("Xiamen")
```



```{r}
class(c(TRUE,FALSE))

```



##  常用的数据类型

数据类型  |    说明
----------|------------------------------------------
vector    | 向量，元素可以是数值、字符串、逻辑值
factor    | 因子，水平，是离散的，以整数vector形式储存，映射到字符串上
matrix    | 矩阵，所有元素的类型(numeric, character等)需一致
data frame| 数据表，和matrix类似，但每列的类型可以不一致
list      | 清单，与vector类似，但每个元素的类型可以不一致，且可以是任何数据类型（例如numeric,data frame, list...)




## 数据类型强制转化（`coercing`）


```{r}
t_1 <- c("1", "2", "3.4") #字符，无法进行计算
t_1
class(t_1)
t_2 <- as.numeric(t_1) #转化为数值，就可以计算了
t_2
class(t_2)
```



```{r}
t_3 <- as.factor(t_2) #数值转化为因子，非常有用的功能，以后详述
t_3
class(t_3)
```




## 缺失值（`NA`）和无穷大（`Inf`）

实验数据经常会有缺失值，缺失值的处理对于数据分析非常重要。


```{r}
v0 <- c(1, 3, 4, NA) #第4个数缺失  
v0

is.na(v0) #判断是否有缺失值
v0[is.na(v0)] <- 0 #将缺失值替换为0
v0
```




```{r}
logv0 <- log(v0) #对数据进行自然对数转化，产生了负无穷大值（-Inf）
logv0
is.infinite(logv0) # 检查是否有无穷大，包括Inf和-Inf

logv0[is.infinite(logv0)] <- NA #将无穷大替换为缺失值NA
logv0

```




## 向量（vector）

### 用函数`c( )`生成向量
>"c"的含义:
>1. combine  
>2. concatenate [kɒn'kætɪneɪt] vt.把 （一系列事件、事情等）联系起来  


* **数值向量**  

```{r}
v1 <- c(1.4, 3, 10.9, -7)
v1
```

* **字符向量**  

```{r}
v2 <- c("apple","organge","banana")
v2
```




* **逻辑值向量**  

```{r}
v3 <- c(TRUE,FALSE,TRUE,FALSE)
v3
```





### 用 `seq()`生成等差序列  

```{r sequence}
seq(from = 10, to = 100, by = 10) 

```

from是第一个值，to是最后一个值，by是相邻两个数的间隔值。  
可以简略成(默认第1个数赋给`from`，第2个数赋给`to`，第3个数赋给`by`) :
```{r}
seq(10, 100, 10)

```


怎么使用`seq()`函数？--查看帮助信息。

执行代码`?seq`， 你会在Help栏看到如下信息:

> Usage  
>seq(...)  
>Default S3 method:  
>seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
>    length.out = NULL, along.with = NULL, ...)  


  
耐心读一读，你可以看懂。读懂之后，你还可以这么使用`seq()`：

```{r}
seq(10, 100, length.out = 19)
```
`length.out`是数列的长度

```{r}
v2 <- seq(10, 100, length.out = 19)
v2[12]
```



### 用`:`符号生成连续自然数序列

```{r}
1:10
v3 <- 20:30
v3
```



### 用**`rep()`**重复元素，生成向量

```{r}
rep(8, 5)
rep("ha", 6)
```



 
```{r}
rep(1:3, 2)
rep(1:3, each = 3)
rep(1:3, each = 3, times=2)

```


这个功能在自动填充数据表s时非常有用，例如，填充treatment，replicate编号。


### 向量信息提取与运算  
```{r message = F, error = T}
v1 <- c(1.4, 3, 10.9, -7)
v1[3] # 引用第3个元素
v1 + 10 # 每个元素均加10
v1 * 10 # 每个元素均乘以10
v1^2 #每个元素均求平方
```




### 针对向量的统计运算


```{r }
v4 <- seq(60, 100, 5)
v4
summary(v4) 
mean(v4) #算术平均值
median(v4) #中位数

```



```{r}
sd(v4) # 标准差
min(v4) # 最小值
max(v4) # 最大值
range(v4) #范围：最小值～最大值
```




## 矩阵（matrix）

### 用`matrix()`函数生成一个矩阵

```{r}
m1 <- matrix(1:18, nrow=3, ncol=6)
m1

```

默认按列排元素，可用`byrow`更改为按行排
```{r}
m2 <- matrix(1:18, nrow=3, ncol=6, byrow=T)
m2
```



## 数据表（data frame）

### 用`data.frame()`函数生成一个数据表

数据表储存以下信息：学生姓名、性别、考试分数
```{r}
student <- c("Tom", "Jack", "Mingming", "Alice", "Feifei")
sex <- c("Male", "Male", "Male", "Female", "Female")
score <- c(83, 72, 80, 92, 95)

data.frame(student, sex, score)

```



可将该数据表储存于变量**`d1`**中，也可以说给数据表取个名字叫**`d1`**
```{r}
d1 <- data.frame(student, sex, score)
```




### 引用`data.frame`中的信息  

引用**`d1`**数据表的**`student`**列有两种方法，一种是用名称，一种是用编号：
```{r}
d1$student 

d1[ , 1] #逗号前是行号，逗号后是列号

```


引用**`d1`**数据表第2个学生的成绩有两种方法，一种是用名称，一种是用编号:  

```{r}
d1$score[2]
d1[2, 3] 
```



### 查看base R自带的数据

```{r}
data() #用此函数查看R自带的数据，以下是节选。
``` 
可以用这些数据来测试、交流你的统计、绘图代码。

数据名称 |简介
--------------|--------------------------
BOD           |Biochemical Oxygen Demand  
ChickWeight   |Weight versus age of chicks on different  
ToothGrowth   |The Effect of Vitamin C on Tooth Growth in Guinea Pigs
co2           |Mauna Loa Atmospheric CO2 Concentration
iris          |Edgar Anderson's Iris Data
mtcars        |Motor Trend Car Road Tests
npk           |Classical N, P, K Factorial Experiment
precip        |Annual Precipitation in US Cities
pressure      |Vapor Pressure of Mercury as a Function of Temperature
rivers        |Lengths of Major North American Rivers


---
  
### 查看数据表的常用命令
  
* 查看数据**`iris`**表头（默认前6行，可更改）  

```{r}
head(iris )
```

--
  
* 查看表尾（默认最后6行，可更改，此处改为4行）  

```{r}
tail(iris, 4)
```



* 查看数据表有哪些变量   

```{r}
names(iris) 
```
以上结果显示5个变量的名称，**每1列是1个变量**。



* 查看数据表的尺寸（dimension），即**行数**和**列数**
```{r}
dim(iris) 
```
结果显示150行，5列。



`length()`显示数据表的列数，即变量数；显示vector的长度，即元素数。
```{r}
length(iris) #5列
length(iris$Species) #150行
```





### 查看数据表的其他性质  

* **查看数据表的结构**
```{r}
str(iris)    

```
前4列均为**`numeric`**，最后一列为**`factor`**  




* **查看数据表的概要**

```{r}
summary(iris)
```
包含了每列的最小值、25%分位数、中位值、均值、75%分位数、最大值



* **查看`iris`这个对象（object）的类型**  

```{r}
class(iris) 
```
当然是**data.frame**类型。



### 合并数据表

```{r}
d1
```



```{r}
d2 <- data.frame(age = c(20, 19, 20, 21, 19))
d2
```




* 合并列（**`column binding`**）
```{r}
cbind(d1, d2) 
```




* 合并行（**`row binding`**）
```{r}
rbind(d1, d1)
```




## 读入数据

四种方法：

代码 | 说明
-----|----------------------------
`d1 <- read.table("clipboard", head = T)` | 从剪贴板（ctrl+C）直接读取，适合于小数据表的快速操作
`d2 <- read.csv(file.choose())` | 弹出对话框，点击鼠标选取文件，读取`csv`格式的数据
`d3 <- read.csv("你的文件名.csv")` |从工作目录下直接读取`csv`格式的数据
`d4 <- read_excel("你的文件名.xlsx", sheet = 1)` | 直接读取`xlsx`文件中某个sheet（此处为sheet1）中的数据，需先加载`readxl`程序包




##  输出数据

`co2`是R自带的时间序列数据，此处将其转化为`data.frame`，用**`write.csv()`**函数将数据储存于名为“CO2_data.csv”的文件中。你可在工作文件夹下找到该文件。 
```{r error=TRUE}
d_CO2 <- data.frame(time = time(co2), CO2 = co2) 

write.csv(d_CO2, "CO2_data.csv")

```



## Base R简单作图



### 默认的`plot()`函数  

绘制散点图，可用于快速了解数据。
```r 
plot(x = d_CO2$time, y = d_CO2$CO2)
```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2)
```


---

### 修改为折线图


```r
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l")
```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l")
```

---

### 修改颜色设置


```{r} 
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red")
```


```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red")
```




### 修改坐标轴名称


```{r} 
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red", xlab = "Year", ylab = expression(pCO[2]~"(ppm)"))

```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red", xlab = "Year", ylab = expression(pCO[2]~"(ppm)"))

```




## `ggplot`作图

先对`ggplot`绘图有个简单印象，下次课我们深入学习。


```{r}
library(ggplot2) #ggplot绘图
ggplot(d_CO2, aes(time, CO2))+
  theme_bw()+
  geom_line(color = "red2")+
  labs(x = "Year",
       y = ~pCO[2]~(ppm))

#ggsave("pCO2.png", width=342/90, height=243/90, dpi=600)
```





## 保存图片

### 第一种方法  
首先将图片赋值给变量**`p1`**。 

```r
library(ggplot2)

p1 <- ggplot(mpg, aes(displ, hwy))+
  geom_point()
```

然后调用**`png()`**作图设备作图，并记得随手用**`dev.off()`**关闭作图设备（否则不出图）。变量**`p1`**夹在以上两行代码之间。完成操作后，你就能在工作文件夹里找到名称为“myplot_1.png”的图了。

```r 
png("myplot_1.png", width=359/90*600, height=239/90*600, res=600)
p1
dev.off()
```




## 保存图片

### 第二种方法  

由于我们以后大多使用**`ggplot()`**作图，因此可以用**`ggplot2`**程序包中的**`ggsave()`**函数保存当前显示的图片（在RStudio右下面板中）。
```r 
library(ggplot2)
ggplot(mpg, aes(displ, hwy))+
  geom_point()

ggsave("myplot_2.png", width=359/90, height=239/90, dpi=600) #png格式，位图
ggsave("myplot_2.pdf", width=359/90, height=239/90) #pdf格式，矢量图
```

完成以上操作，你就能在工作文件夹里找到名称为“myplot_2.png”“myplot_2.pdf”的图了。

>如何设置合适的**`width`**和**`height`**?  
>需要一些技巧（我会操作演示）和审美能力。




### 推荐阅读
Crawley MJ. The R Book. 2nd ed. Chapter 2. Essentials of the R Language.pp 12-136.
(有点枯燥，至少读1/3，读不完的之后的学习过程中还可以再回过头读。)


<!--chapter:end:01-intro.Rmd-->

# `ggplot2`作图入门



### ggplot基本理念  

图层、映射  


展开画布，一张空图  
```{r}
library(ggplot2)

ggplot()
```


数据有了，但还不知道要画什么图，仍然是一张空图  
```{r}
ggplot(mpg)
```

知道了谁是`x`
```{r}
ggplot(mpg)+
  aes(x = displ)
```

知道了谁是`y`
```{r}
ggplot(mpg)+
  aes(x = displ)+
  aes(y = hwy)
```

知道了要画什么图，图就有了  
```{r}
ggplot(mpg)+
  aes(x = displ)+
  aes(y = hwy) +
  geom_point()
```


把`aes()`收进`ggplot()`，代码显得紧凑  
```{r}
ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point()
```

颜色映射到变量`class`，
```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = class))+
  geom_point()
```

颜色映射放在ggplot里，会管住所有图层    
```{r warning=FALSE}
ggplot(mpg, aes(x = displ, y = hwy, color = class))+
  geom_point()+
  geom_smooth()
```


颜色映射放在`geom_point()`里，只能管住`geom_point()`图层，对其他图层不起作用  
```{r warning=FALSE}
ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point(aes(color = class))
  

ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point(aes(color = class))+
  geom_smooth()
```




## 以R自带的数据**`ToothGrowth`**为例
先用敲入代码**`?ToothGrowth`**来了解一下数据。
>The Effect of Vitamin C on Tooth Growth in Guinea Pigs (豚鼠)  
> Description  
> The response is the length of odontoblasts (cells responsible for tooth growth) in 60 guinea pigs. Each animal received one of three dose levels of vitamin C (0.5, 1, and 2 mg/day) by one of two delivery methods, orange juice or ascorbic acid (a form of vitamin C and coded as VC).  

> Format  
> A data frame with 60 observations on 3 variables.  

>[,1]	len	numeric	Tooth length  .red[第1列是数值变量，牙齿长度]  
>[,2]	supp	factor	Supplement type (VC or OJ) .red[第2列是因子，补充剂类型，维C还是橙汁]  
>[,3]	dose	numeric	Dose in milligrams/day  .red[第3列是数值变量，补充剂的剂量]  

> References
> Crampton, E. W. (1947). The growth of the odontoblast of the incisor teeth as a criterion of vitamin C intake of the guinea pig. The Journal of Nutrition, 33(5), 491–504. doi: 10.1093/jn/33.5.491.



---

##了解一下**`ToothGrowth`**的内容

先用**`head()`**来看看数据长什么样：

```{r}
head(ToothGrowth)
```
再用**`str()`**具体了解一下数据概况：
```{r}
str(ToothGrowth)
```

---

## 开始作图  

* 使用`ggplot()`作图，需先加载`ggplot2`程序包  
* 可以略去“`x=`”，“`y=`”，使代码更简洁；第1个数默认给x，第2个默认给y


```{r}
library(ggplot2) #加载ggplot2包

ggplot(ToothGrowth, aes(x=dose, y=len))+
  geom_point()
```


```{r}
#简洁代码：
ggplot(ToothGrowth, aes(dose, len))+
  geom_point()
  
```




## 用颜色"**`color=`**"区分不同处理  

* 将颜色（`color`）映射（mapping）到补充剂类别（`supp`）上，即用不同颜色区分“VC”和“橙汁”数据  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, color=supp))+
  geom_point()  
  
```





## 用形状"**`shape=`**"进一步区分不同处理

- 将点的形状映射到补充剂类别上，即用不同形状区分“VC”和“橙汁”数据    
- 黑白打印、色盲友好  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, color=supp,shape=supp))+
  geom_point()  
  
```



## 用"**`stat_summary()`**"添加平均值

- 我们喜欢看平均值  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  geom_point()+
  stat_summary(geom="line", fun="mean")
  
```
]





## 用"**`stat_summary()`**"添加平均值

- 去掉散点，加上平均值对应的点  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
 #geom_point()+ #加上井号的作用：使这行代码变为注释，不运行
  stat_summary(geom="line", fun="mean")+
 stat_summary(geom="point", fun="mean")
  
```





---

## 用"**`stat_summary()`**"添加误差棒

- 计算标准差的函数是`sd()`；误差棒：`errorbar`


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x),          fun.max=function(x) mean(x)+sd(x)) #自定义函数计算标准差；还有很多其他方法，目前这个方法最容易理解
  
```





## 用"**`stat_summary()`**"添加误差棒

- 美化一下误差棒


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), width=0.1) #把误差棒变窄，试试改为0
  
```




 我的数据不是这种格式啊!  




```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
d_tooth <- ToothGrowth %>%
  group_by(supp, dose) %>%
  summarise(mean = mean(len), 
            sd = sd(len))

d_tooth$mean <- round(d_tooth$mean, 2)
d_tooth$sd <- round(d_tooth$sd, 2)

d_tooth_wide <- cbind(d_tooth[1:3,],d_tooth[4:6,])

```



```{r, echo=FALSE}

knitr::kable(d_tooth, format = "html")
```



##  甚至是这样的

```{r, echo=FALSE}
knitr::kable(d_tooth_wide, format = "html")

```



  ## 这样的数据不方便统计分析，以后别这样了

- 左边的长表格格式整齐，R可以直接处理，但缺点是丢失了原始信息
- 右边的宽表格R不能直接处理（可以转化，之后课程会讲）




## 这样才是好的格式，这叫**Tidy Data**

```{r eval=require('DT'),  echo=FALSE}
DT::datatable(
  ToothGrowth,
  fillContainer = FALSE, options = list(pageLength = 8)
)
```



## Tidy Data 整齐数据  

> ### Tidy data is data where:

> ### Each variable is in a column. .red[每1列对应1个变量]
> ### Each observation is a row. .red[每1行对应1个样本、1次观察]
> ### Each value is a cell. .red[每1格包含1个值]


[阅读材料：What is “Tidy Data”? https://www.r-bloggers.com/what-is-tidy-data](https://www.r-bloggers.com/what-is-tidy-data/)



### 修改细节，使之规范   


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  theme_bw()+ #使用黑白主题，默认的是灰色主题
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), width=0.1)+
  labs(x="Dose (mg/day)", #x轴标签
      y="Tooth length (mm)", #y轴标签
      color="Supplement", #颜色标签
      shape="Supplement")+ #形状标签，与颜色的一致
  scale_y_continuous(limits=c(0, NA))+ #y轴取值范围
  theme(legend.position=c(0.8, 0.2), #图例的位置，左下角为(0,0),右上角为(1,1)
        legend.background = element_blank(), #使图例方框背景透明
        legend.key = element_blank()) #使图例符号背景透明
```



##`ggasve()`保存

- 保存下来的图片显示质量比预览的效果更好一些
```r
ggsave("tooth_1.png", width=280/90, height=224/90, dpi=600)
```

## 当然，用“均值+标准差”格式的数据也可以作图


将此数据命名为**`d_tooth`**  

```{r, echo=FALSE}

knitr::kable(d_tooth, format = "html")
```

- **`d_tooth`**可以通过以下代码得到：  

```{r}
library(dplyr)
d_tooth <- ToothGrowth %>%
  group_by(supp, dose) %>%
  summarise_at(vars(len), funs(mean, sd))
```



## 当然，用“均值+标注差”格式的数据也可以作图

- **用`geom_line()`画折线；`geom_errorbar()`画误差棒**


```{r}
 ggplot(d_tooth, aes(x=dose, y=mean, 
 color=supp, shape=supp))+
   theme_bw()+ 
   geom_point()+ #画点
   geom_line()+ #画线
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)+ #画误差棒，注意误差棒的上下限需用aes()映射到mean和sd上
   labs(x="Dose (mg/day)", 
        y="Tooth length (mm)", 
        color=NULL, #去掉了颜色标签
        shape=NULL)+ #去掉了形状标签
   scale_y_continuous(limits=c(0, NA))+ 
   theme(legend.position=c(0.8, 0.2), 
         legend.background = element_blank(), 
         legend.key = element_blank()) 
  
```




## 用`geom_col()`画柱状图
- 不要用`geom_bar()`画柱状图--不是不可以，只是不是按你想的那样


```{r}
ggplot(d_tooth, aes(x=dose, y=mean, color=supp))+
   geom_col()+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)

```



这不是我们想要的



### 柱子的颜色用**`fill`**，柱子的边框才是**`color`**
### 若有多组柱子，需要`dodge`让他们错开，否则默认`stack`堆叠


```{r}
ggplot(d_tooth, aes(x=dose, y=mean,  fill=supp))+
  geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)

```


 

### 用**`position = position_dodge()`**，错开多组误差棒


```{r}
ggplot(d_tooth, aes(x=dose, y=mean, fill=supp))+
   geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1,
                 position=position_dodge(width=0.45))

```
 


### 把x轴的`dose`变为`factor`类型，使柱子之间等间隔


```{r}
  ggplot(d_tooth, aes(x=factor(dose), y=mean, fill=supp))+
   geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1,
                  position=position_dodge(width=0.9)) #注意width也改为0.9，这个可以试错出来

```
 

## 修改细节，使之规范  


```{r}
ggplot(d_tooth, aes(x=factor(dose), y=mean, fill=supp))+
  theme_bw()+
  geom_col(position="dodge", width = 0.7)+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd, color=supp), width=0.1, position=position_dodge(width=0.7))+
  labs(x=expression("Dose (mg"~d^"-1"*")"),
       y="Tooth length (mm)",
       fill=NULL, color=NULL)+
  theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())
```


##柱状图完成，`ggasve()`保存

- 除了默认的颜色土一点，基本达到发表的要求了（颜色以后我们专题讨论）

```r
ggsave("tooth_2.png", width=316/90, height=232/90, dpi=600)
```


## 直接用`Tidy Data`（`ToothGrowth`）作柱状图 


```{r}
ggplot(ToothGrowth, aes(x=factor(dose), y=len, fill=supp))+
  theme_bw()+
  stat_summary(geom="col", fun="mean", position="dodge", width = 0.7)+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), aes(color=supp), width=0.1, position=position_dodge(width=0.7))+
  labs(x=expression("Dose (mg"~d^"-1"*")"),
       y="Tooth length (mm)",
       fill=NULL, color=NULL)+
  theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())
```




## 用`geom_boxplot()`画箱式图  


```{r}
ggplot(ToothGrowth, aes(dose, len,  color=supp))+
 geom_boxplot()

```




- **问题出在哪：`dose`是连续变量（`numeric`格式），不适合boxplot，需先转化为`factor`**




## 用`factor()`将数值变量转化为因子  


```{r}
 ggplot(ToothGrowth, aes(factor(dose), len,  color=supp))+
  geom_boxplot()

```





##修饰细节，使之规范   


```{r}
ggplot(ToothGrowth, aes(factor(dose), len,  color=supp))+
   theme_bw()+
geom_boxplot()+
    labs(x=expression("Dose (mg"~d^"-1"*")"),
        y="Tooth length (mm)", color=NULL)+
   theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())

```






---

## 要点小结


图         | 函数
-----------|--------------------
点         |`geom_point()`
线         |`geom_line()`
柱         |`geom_col()`推荐； `geom_bar()`
箱         |`geom_boxplot()`
误差棒     |`geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd))`
统计-误差棒| `stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x))`
统计-均值点|`stat_summary(geom="point", fun="mean")`
统计-均值线|`stat_summary(geom="line", fun="mean")`

---

## 阅读作业  

### Hadley Wickham. 2016. ggplot2 Elegant Graphics for Data Analysis.
- .large2[Chapter 2. Getting Started with ggplot. pp. 11-32]
- .large2[Chapter 3. Toolbox. pp. 33-74]





## 进阶：拟合及结果可视化  
* R自带的另一套数据**`DNase`**
> **Elisa assay of DNase**   
> Description  
> The DNase data frame has 176 rows and 3 columns of data obtained during development of an ELISA assay for the recombinant protein DNase in rat serum.  

>Source  
>Davidian, M. and Giltinan, D. M. (1995) Nonlinear Models for Repeated Measurement Data, Chapman & Hall (section 5.2.4, p. 134

###这套数据和我们研究中遇到的数据很类似。用ELISA方法测定大鼠血清中的DNA酶，得到酶浓度和吸光度数据。实验做了11次，每次测定有平行样。


## 先用**`head()`**和**`str()`**来查看数据  

```{r }
head(DNase)
```



```{r highlight.output = 2:4}
str(DNase)
```


注意：`Run`虽然是数字，类型却是`factor`，因此后面`facet`时可以直接操作，而无需转化为`factor`。


## 散点图是我们对数据进行探索分析的法宝  




```{r}
library(ggplot2)
ggplot(DNase, aes(conc, density))+
  geom_point()
```


这个数据让你想起了什么？有点像酶反应里的米氏动力学。确定分析方向：用米氏方程去拟合数据



## 均值+标准差（换一种方法）


```{r}
ggplot(DNase, aes(conc, density))+
  geom_point(stat="summary", fun="mean")+
  geom_errorbar(stat="summary", 
                fun.min=function(x) mean(x)-sd(x), 
                fun.max=function(x) mean(x)+sd(x), width=0.2)

```

 
## 对比两种等价的作图方法  


方法1             |   方法2  
------------|----------------
`geom_errorbar(stat="summary",...)` | `stat_summary(geom="errorbar",...)`
`geom_point(stat="summary",...)` | `stat_summary(geom="point",...)`
`geom_line(stat="summary",...)` | `stat_summary(geom="line",...)`
... | ...



## **`nls()`**非线性拟合米氏方程：手动提取拟合结果  

- 米氏方程： $V=\frac{V\text{max}\times C}{K_\text{M}+C}$

- 非线性拟合  
拟合前，仔细观察原始数据，运用你的智慧大致判断一下Vmax和KM的值

```{r highlight.output = 4:5}
nls(density ~ conc * Vmax/(KM + conc), data=DNase, start=list(Vmax=2, KM=6) )
```
-  手动赋值
```{r}
Vmax <- 2.280 
KM <- 3.682
```




## **`nls()`**非线性拟合米氏方程：自动提取拟合结果-1  

- 将拟合结果存入**`fit`**

```{r }
fit <- nls(density ~ conc * Vmax/(KM + conc), data=DNase, start=list(Vmax=2, KM=6) )
```



- 查看结果  
```{r highlight.output=6:7}
summary(fit)
```





## **`nls()`**非线性拟合米氏方程：自动提取拟合结果-2  

- 查看都储存了哪些信息  
```{r}
names(summary(fit)) 
```



- 提取我们需要的参数拟合值  

```{r}
summary(fit)$coefficients

Vmax <- summary(fit)$coefficients[1]

KM <- summary(fit)$coefficients[2]
```


## 生成画拟合线所需的数据  

- 生成数据  

```{r}
fit_x <- seq(0, 14, length.out=100) #生成100个x，涵盖原始数据范围
fit_y <- Vmax * fit_x /(KM + fit_x) #将x和参数值代入米氏方程，计算y


d_fit <- data.frame(conc=fit_x, density=fit_y) #注意命名和原数据保持一致，可以不一致，但一致的话画图更简单
```



- 查看一下所生成的数据  

```{r}
head(d_fit)
```


## 添加拟合线


```{r}
ggplot(DNase, aes(conc, density))+
  geom_point(stat="summary", fun="mean")+
  geom_errorbar(stat="summary", 
                fun.min=function(x) mean(x)-sd(x), 
                fun.max=function(x) mean(x)+sd(x), width=0.2)+
  geom_line(data=d_fit) #不需要设定aes(x=,y=)，因为继承了第1行代码的设定；如果xy名字与原数据不一样，则需设定。

```



## 修饰细节  


```{r}
ggplot(DNase, aes(conc, density))+
  theme_bw()+
  geom_line(data=d_fit, size=0.7, alpha=0.7, color="red2")+
  geom_point(stat="summary", fun="mean", color="grey30", alpha=0.7)+
  geom_errorbar(stat="summary", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), width=0.2)+
  labs(x=expression("DNase concentration (ng"~mL^"-1"*")"),
       y="Optical density")+
  annotate(geom="text", x=10, y=0.5,label=expression(OD==frac(OD[max], italic(K)[M]+italic(C)))) # 添加公式
```


## 如何在图上添加数学公式？

1. `annotate(geom="text", x=..., y=..., label=...)`
1. .red[`?plotmath`]查看各种公式的代码  



- 例如：  

Syntax |	Meaning ||Syntax |	Meaning
-------|-------------|--|---------|-------------
x + y	|x plus y ||sqrt(x)	|square root of x
x - y	|x minus y ||x == y	|x equals y
x %+-% y	|x plus or minus y ||italic(x)	|draw x in italic font
x %.% y	|x cdot y ||alpha -- omega	|Greek symbols
x[i]	|x subscript i ||frac(x, y)	|x over y
x^2	 |x superscript 2 ||... | ...




## 另一个探索数据的超级武器：分面**`facet`**



**有两种分面：**  
- `facet_wrap(~因子)`：针对1个因子，1维分面  
- `facet_grid(因子1~因子2)`：针对2个因子，2维分面  

```{r}

ggplot(DNase, aes(conc, density))+
  geom_point()+
 facet_wrap(~Run) # 针对Run这个因子分面
```

- **每个Run都单独作图，数据趋势类似**  
- **每组数据可以单独拟合，看看参数的变异程度**  
  




## 运用`for()`循环语句，批量拟合11组数据


```{r}
N <- length(unique(DNase$Run)) # 有几组数据？直译：不重复的Run这个向量的长度

Vmax_each <- numeric(N) #生成长度为N的向量，以备存储拟合值
KM_each <- numeric(N)

#运用循环语句，每次拟合1组数据
for (i in 1 : N) {
d_i <- subset(DNase, Run==i) #把第i组数据筛选出来
fit_i <- nls(density ~ conc * Vmax/(KM + conc), data=d_i, start=list(Vmax=2, KM=6) )
Vmax_each[i] <- summary(fit_i)$coefficients[1] #第i个拟合结果存入向量第i个位置
KM_each[i] <- summary(fit_i)$coefficients[2] #同上
}
```



- 将拟合值存入数据表备用
```{r}
d_Vmax_KM <- data.frame(Vmax_each, KM_each) 

```



##查看一下11组拟合结果

```{r}
d_Vmax_KM


```


```{r}
mean(Vmax_each)
sd(Vmax_each)
mean(KM_each)
sd(KM_each)

```


## 生成画11条拟合线的数据

```{r}
fit_x_11 <- rep(seq(0, 14, length.out=100), times=11) #生成等间距x值100个，重复11次
Vmax_11 <- rep(Vmax_each, each=100) #复制Vmax，复制100份
KM_11 <- rep(KM_each, each=100) #复制KM，复制100份
fit_y_11 <- Vmax_11 * fit_x_11 /(KM_11 + fit_x_11) #将以上三者代入米氏方程，计算y（想象一下你熟悉的excel，操作其实是一样的）
Run <- rep(1:11, each=100) #复制Run编号，复制100份

d_fit_11 <- data.frame(conc=fit_x_11, density=fit_y_11, Run=Run)
```


## 画11条拟合线  


```{r} 

ggplot(DNase, aes(conc, density))+
  geom_point()+
  facet_wrap(~Run)+
 geom_line(data=d_fit_11) # 把11条拟合线画上去

```

 

## 修改细节  


```{r} 
#把这11个Run从1到11重新排好顺序
DNase$Run <- factor(DNase$Run, 
                    levels=c("1","2","3","4","5","6",
                    "7","8","9","10","11")) 
d_fit_11$Run <- factor(d_fit_11$Run, 
                    levels=c("1","2","3","4","5","6",
                    "7","8","9","10","11")) 
                    
ggplot(DNase, aes(conc, density))+
  theme_bw()+
  geom_point(alpha=0.6)+
  facet_wrap(~Run)+
  geom_line(data=d_fit_11, size=0.7, color="red2")+
    labs(x=expression("DNase concentration (ng"~mL^"-1"*")"),
         y="Optical density")

```



---
## 图上各主题元素的修改方法
参考此网页：https://ggplot2.tidyverse.org/reference/theme.html
---
## 要点小结

**理解两种等价的作图方式**(若有困难，选一种你觉得容易理解的记住)
- `geom_xxx(stat="summary") == stat_summary(geom="xxx")` 

**添加拟合线** 
- `nls()`非线性拟合 
- `summary()`查看、提取拟合结果
- `seq()`，`rep()`生成作图数据的有力工具

**添加数学公式**
- `annotate()` 往图上添加公式、文字
- `?plotmath` 查看数学公式对应的代码

**`facet`分面功能**：数据分析的世界因此而美好

**`for()`循环语句**：把重复的工作交给电脑







<!--chapter:end:02-ggplot.Rmd-->

# 颜色的使用



## 颜色的使用

* 离散变量-自动配色  
* 离散变量-手动配色  
* 连续变量-自动配色  
* 连续变量-手动配色  



## 离散变量-自动配色
`scale_color_brewer(palette=...)`
`scale_fill_brewer(palette=...)`

```{r}
p1 <- ggplot(mpg, aes(displ, hwy, color = class))+
  geom_point()
p1  

p2 <- ggplot(mpg, aes(class, fill = class))+
  geom_bar()
p2
```


### 查看R系统自带配色
用`?scale_color_brewer`查询  

* 点图--使用各种自动配色:以mpg数据为例  
Qualitative（定性色）  
Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3  
更适合于连续变量。适用于热图、等高线图、地图等  


```{r}
library(RColorBrewer)

RColorBrewer::brewer.pal.info
  
RColorBrewer::display.brewer.all()
RColorBrewer::brewer.pal.info
rownames(RColorBrewer::brewer.pal.info)
```

### 使用R系统自带配色



```{r}
p1 + scale_color_brewer(palette="Set1")
p2 + scale_fill_brewer(palette="Set1")


p1 + scale_color_brewer(palette="Set3")
p2 + scale_fill_brewer(palette="Set3")


p1 + scale_color_brewer(palette = "Accent")
p2 + scale_fill_brewer(palette = "Accent") 

p1 + scale_color_brewer(palette = "Dark2")
p2 + scale_fill_brewer(palette = "Dark2") 

p1+ scale_color_brewer(palette = "BrBG")
p2 + scale_fill_brewer(palette = "BrBG")
```


### 色盲友好的viridis配色  
`?scale_fill_viridis_d` 

```{r}
p1 + scale_color_viridis_d()
p2 + scale_fill_viridis_d()


p1 + scale_color_viridis_d(option = "A")
p2 + scale_fill_viridis_d(option = "A")

p1 + scale_color_viridis_d(option = "B")
p2 + scale_fill_viridis_d(option = "B")

p1 + scale_color_viridis_d(option = "F")
p2 + scale_fill_viridis_d(option = "F")
```



* 离散变量-手动配色  
`scale_color_manual(values=...)`
`scale_fill_manual(values=...)`


```{r}
p1 + scale_color_manual(values=c("red","orange","yellow","green","blue","grey","black"))
p2 + scale_fill_manual(values=c("red","orange","yellow","green","blue","grey","black"))
```

### 如何知道各种颜色的名称？`colors()`



```{r}
colors()
colors()[1:9]
```

```{r}
scales::show_col(colors()[100:108])
```



### 如何预览各种颜色？ `scales::show_col()`
```{r}
library(scales)
show_col("springgreen")

show_col(c("springgreen","snow4","violetred","skyblue1",
           "steelblue1","navy", "lightsteelblue3","turquoise2","rosybrown"))
show_col(colors()[10:20])
```

### 如何设置出谐调、美观、科学的配色？  
去配色程序包里找，去配色网站找，去艺术品里找，去大自然找。

 查看颜色的程序包
 
```{r}
RColorBrewer::brewer.pal(n=8, name = "Set1")

mycol <- RColorBrewer::brewer.pal(n=8, name = "Set1")
mycol
show_col(mycol)

brewer.pal(8, "Set1") #提取“Set1”配色中的颜色代码
show_col(brewer.pal(8, "Set1"))
```

 
`ggsci` 配色程序包  

```{r}

library(ggsci)

ggsci::pal_aaas()(10)
show_col(ggsci::pal_aaas()(10))

ggsci::pal_npg()(10)
show_col(ggsci::pal_npg()(10))

show_col(ggsci::pal_simpsons()(10))


ggsci::pal_aaas()(10)
show_col(ggsci::pal_aaas()(10))



p1 + scale_color_aaas()
p2 + scale_fill_aaas()

p1 + scale_color_npg()
p2 + scale_fill_npg()

p1 + scale_color_manual(values=ggsci::pal_aaas()(10))
p2 + scale_fill_manual(values=ggsci::pal_aaas()(10))

ggsci::pal_d3()(10)
show_col(ggsci::pal_d3()(10))

ggsci::pal_futurama()(10)
show_col(ggsci::pal_futurama()(10))
  
ggsci::pal_gsea()(10)
show_col(ggsci::pal_gsea()(10))
  
ggsci::pal_nejm()(10)
show_col(ggsci::pal_nejm()(10))

ggsci::pal_npg()(10)
show_col(ggsci::pal_npg()(10))
```


去大自然里找，去生活里找  

```{r}
pal_cee <- c("#DA1718", "#CE9F9F", "#36536D", "#5092E1", "#D8E8F9", "#526B13",  "#97B325", "#876454", "#C0C0CC")
show_col(pal_cee)

p1 + scale_color_manual(values=pal_cee)
p2 + scale_fill_manual(values=pal_cee)

```

去艺术品里找 
```{r}
pal_qljs <- c("#1F394D", "#EEC979", "#C4CBC2", "#5A6683", "#BB9555", "#CDE5BC", "#356183", "#24211F", "#E9C3BC")
show_col(pal_qljs)              

p1 + scale_color_manual(values=pal_qljs)
p2 + scale_fill_manual(values = pal_qljs)
```


* 网站配色
https://coolors.co/
5种颜色一组，地址栏直接获取Hex颜色代码

https://medialab.github.io/iwanthue/
颜色数量较多时自动配色


* Pantone配色
```{r}
Pantone <- c("#34558b", "#d13b40", "#ffaf12", "#4ec5a5", "#565d47", "#798fa8", "#fd823e",  "#117893", "#f0daa4", "#eaac9d", "#a2553a", "#72617d", "#b49c73", "#3b3d4b", "#eff0f1", "#a09d9c", "#191970", "#bc243c", "#585ea6", "#F5DF4D")


show_col(Pantone)
```



## 连续变量-自动配色
`scale_color_distiller(palette=...)`
`scale_fill_distiller(palette=...)`

代码：颜色映射到连续变量
scale_fill_distiller(palette=...)  利用系统的配色方案插值得到连续配色，常用


```{r}
d2 <- tidyr::crossing(x = seq(-10, 10, 0.1), y = seq(-10, 10, 0.1)) %>%
  mutate(z = sin(sin(x * (sin(y) - cos(x)))) - cos(cos(y * (cos(x) - sin(y)))))


p <- ggplot(d2, aes(x, y)) +
  geom_raster(aes(fill = z))
p
p <- p + coord_equal()
p
```


Sequential（渐变色）
Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd

Diverging（分裂色）
BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral

`scale_color_brewer(palette =...)`  使用自动配色方案，常用
`scale_color_manual(values = c(...))`  手动配色，常用

### 自动配色  
```{r}

RColorBrewer::brewer.pal.info
p + scale_fill_distiller(palette = "BrBG")
p + scale_fill_distiller(palette = "PiYG")


p + scale_fill_distiller(palette = "Accent")
p + scale_fill_distiller(palette = "PuBu")

```

系统自带色盲友好`viridis`配色  
```{r}
p + scale_fill_viridis_c(option = "A") 
p + scale_fill_viridis_c(option = "B") 
p + scale_fill_viridis_c(option = "C") 
p + scale_fill_viridis_c(option = "D") 
p + scale_fill_viridis_c(option = "E") 
p + scale_fill_viridis_c(option = "F") 
p + scale_fill_viridis_c(option = "G") 
p + scale_fill_viridis_c(option = "H") 
p + scale_fill_viridis_c(option = "I")
```


`scico`程序包，科学的渐变色    

```{r}
library(scico)

scico::scico_palette_names()

scico::scale_fill_scico(palette = "buda")

  
p + scale_fill_scico(palette = "buda")
p + scale_fill_scico(palette = "batlow")

scico_names <- scico::scico_palette_names()
scico_names 
p + scale_fill_scico(palette = scico_names[1])
p + scale_fill_scico(palette = scico_names[2])
p + scale_fill_scico(palette = scico_names[3])
p + scale_fill_scico(palette = scico_names[4])
p + scale_fill_scico(palette = scico_names[5])
p + scale_fill_scico(palette = scico_names[6])
p + scale_fill_scico(palette = scico_names[7])
p + scale_fill_scico(palette = scico_names[8])
p + scale_fill_scico(palette = scico_names[9])
p + scale_fill_scico(palette = scico_names[10])
p + scale_fill_scico(palette = scico_names[11])
p + scale_fill_scico(palette = scico_names[12])
p + scale_fill_scico(palette = scico_names[13])
p + scale_fill_scico(palette = scico_names[14])
p + scale_fill_scico(palette = scico_names[15])
p + scale_fill_scico(palette = scico_names[16])

```





## 连续变量-手动配色
颜色映射到连续变量
`scale_color_gradient(low=..., high=..., na.value=)` 用两种颜色形成梯度
`scale_color_continuous(low=..., high=...)` 同上
`scale_color_gradient2(low=..., mid=..., high=...)`用三种颜色形成梯度

```{r}
p + scale_fill_gradient(low = "white", high = "black", na.value = "grey96")
```


`scale_color_gradientn(colors=...)` 用n种颜色形成梯度

heat.colors(8)  
terrain.colors(8)

```{r}
p + scale_fill_gradientn(colors=heat.colors(8), na.value="white")
```


## 颜色RGB码的转化
```{r}
rgb(34, 108, 224, max=255) 
```

## 推荐阅读：
科技论文中颜色的误用
Crameri, F., Shephard, G. E., & Heron, P. J. (2020). The misuse of colour in science communication. Nature communications, 11(1), 1-10.
https://www.nature.com/articles/s41467-020-19160-7

如何配色
The Elements of Choosing Colors for Great Data Visualization in R
http://www.sthda.com/english/wiki/the-elements-of-choosing-colors-for-great-data-visualization-in-r

配色工具
R package colortools
https://rpubs.com/gaston/colortools

颜色使用需考虑什么
What to consider when choosing colors for data visualization
https://blog.datawrapper.de/colors/

检测配色是否色盲友好
HOW TO STIMULATE COLORBLINDNESS VISION IN R FIGURES
https://www.datanovia.com/en/blog/how-to-stimulate-colorblindness-vision-in-r-figures/

关于颜色的选择：定性vs定量，单渐变色vs双渐变色，分类vs不分类
https://blog.datawrapper.de/which-color-scale-to-use-in-data-vis/




### 拼图程序包 `cowplot`  
```{r}
p1
p2
library(cowplot)

cowplot::plot_grid(p1, p2)
cowplot::plot_grid(p1, p2, p1, p2,ncol=2, labels=c("a","b","c","d"))


cowplot::plot_grid(p1, p2) 

cowplot::plot_grid(p1, p2, ncol=1)

cowplot::plot_grid(p1, p2, labels = c("a","b"))

cowplot::plot_grid(p1, p2, rel_widths = c(1,2))

```



<!--chapter:end:02b-color.Rmd-->

# 数据整理




## 数据整理
### 3个常用的程序包`dplyr`，`tidyr`，`reshape2`


Package     | 常用函数
------------|--------------------------------------------
`dplyr`     | `select()`，`filter()`，`mutate()`，`arrange()`
            |`group_by()`，`summarise()`
            | `join()`，`%>%`（pipe运算符）
`tidyr`     | `pivot_longer`，`pivot_wider()`
`reshape2`  | `melt()`（老但好用）



## `dplyr`名字的含义

https://github.com/tidyverse/dplyr/issues/1857

hadley commented on 26 May 2016
- The d is for dataframes, the plyr is to evoke pliers. Pronounce however you like.

@kartiksubbarao
- kartiksubbarao commented on 30 Oct 2017
The precursor to dplyr was called plyr. The 'ply' in plyr comes from an expansion/refining of the various "apply" functions in R as part of the "split-apply-combine" model/strategy. Here's a good slideset that provides more insight into the plyr name:

https://www.slideshare.net/hadley/plyr-one-data-analytic-strategy




## `tidyverse`大程序包

**1. `ggplot2`，`dplyr`，`tidyr`等都是`tidyverse`系列的**  
**2. 运行`install.packages("tidyverse")`可以一并安装**  

### `tidyverse`包括以下程序包：  

```{r echo=F, message=F, warning=F}
library(tidyverse)
tidyverse_packages()
```



## 案例分析：美国贻贝观察数据

### NOAA's National Status and Trends###    
### NS&T is comprised of three nationwide programs, Benthic Surveillance, .red[Mussel Watch] and Bioeffects that are designed to describe the current status of, and detect changes in, the environmental quality of our nation's .red[estuarine and coastal waters] through environmental monitoring, assessment and related research.### 


[数据来源：https://products.coastalscience.noaa.gov/collections/ltmonitoring/nsandt/](https://products.coastalscience.noaa.gov/collections/ltmonitoring/nsandt/)



### 初步了解数据

- **已从NOAA网站下载数据，将其命名为.red["MusselWatch20170718.csv"]**

- **读取数据**  

```{r}
d0 <- read.csv("data/MusselWatch20170718.csv") 
```

- **多少行，多少列?**
```{r}
dim(d0) 
```

有127743行，用excel处理会很棘手

- **各列的名称是什么？**  
```{r}
names(d0) 
```



### 测定了哪些类型的样品？  

```{r}
unique(d0$Matrix)
```




### 测定了哪些污染物？  

```{r}
unique(d0$Parameter)
```



### 数据的单位是什么？  

```{r}
unique(d0$Unit)
```

注意：有两种单位，后续分析时需小心，不能把不同单位的数据混在一起分析



## 提出问题

### 1. 牡蛎和贻贝谁的Cd浓度高？
### 2. Zn浓度高的牡蛎，是否Cd浓度也高？

<br>

--

## 目前的数据存在哪些问题：
### 1. 数据太大，冗余信息过多

--

### 2. 存在干重、湿重两种不同的单位



## 整理数据：用`select()`筛选数据的特定列

### 使用“列名”来选择列 
```{r message=FALSE, warning=FALSE}
library(dplyr)
d <- d0 %>%
  select(Fiscal_Year, Matrix, Scientific_Name, Parameter, Value, Unit) 
```


- 检查一下结果是否符合预期：

```{r}
names(d)
```



### 也可以用“列号”进行选择  

- 选择数据`d0`的第8， 10， 14， 16列，存入`d1`

```{r}
d1 <- d0 %>%
  select(8, 10, 14, 16)
```

删去数据`d0`的第1-7列，第9，15列，存入`d2`

```{r}
d2 <- d0 %>%
  select(-c(1:7, 9, 15))
```



## 数据整理： 用`filter()`筛选数据的特定行  

### 筛选出牡蛎和贻贝的数据

```{r }
d_oy.mu <- d %>%
  filter(Matrix %in% c("Oyster", "Mussel")) #<<
```

<br>

注意：筛选多个变量用"`%in%`"，筛选单一变量用"`==`"。



### 检查一下新的数据

```{r }
dim(d_oy.mu)  #行数大为精简
```
```{r highlight.output=1}
unique(d_oy.mu$Matrix)  #只剩下Oyster和Mussel
```


### 再次查看数据的单位  
```{r highlight.output=1}
unique(d_oy.mu$Unit)
```

数据全部是基于干重的了，可以解除警报 



### 也可以用base R的`subset()`筛选数据


- 代码如下：  

```{r}
d_oy_2 <- subset(d, Matrix=="Oyster") 
unique(d_oy_2$Matrix)
```

<br>

此操作简洁快速，适用于筛选步骤不多的场合


## 注意区分`filter()`和`select()` 

`filter()` 用于选择特定的行（即样品、观察)

`select()` 用于选择特定的列（即变量) 




### 筛选出Cd的数据


```{r }
d_oy.mu_Cd <- d_oy.mu %>%
  filter( Parameter == "Cadmium")
```


- 再检查数据

```{r}
dim(d_oy.mu_Cd)
unique(d_oy.mu_Cd$Parameter)
unique(d_oy.mu_Cd$Scientific_Name)
```
发现牡蛎、贻贝共有7个物种，我们把问题1细化到物种


### 可以作个图看看数据了  




- 作散点图  

```{r}
library(ggplot2)
ggplot(d_oy.mu_Cd, aes(Scientific_Name, Value))+
  geom_point()
```





###修改成对数坐标###



当数据之间差异很大时，可以考虑用对数坐标，使数据均匀分散开  

```{r}
ggplot(d_oy.mu_Cd, aes(Scientific_Name, Value))+
  geom_point()+
 scale_y_log10()
```




### 去掉只有2个数据点的物种


```{r}
d_Cd <- d_oy.mu_Cd %>% filter(Scientific_Name != "Crassostrea gigas")
ggplot(d_Cd, aes(Scientific_Name, Value))+
  geom_point()+
  scale_y_log10()+
  theme(axis.text.x = element_text(angle=20, hjust=1)) #x轴上名称太长，旋转20°以便显示
```





### 研究问题1：牡蛎、贻贝，谁的Cd浓度高？



用不同颜色区分牡蛎和贻贝  

```{r}
ggplot(d_Cd, aes(Scientific_Name, Value, color=Matrix))+
   geom_point()+
   scale_y_log10()+
   theme(axis.text.x = element_text(angle=20, hjust=1))
```



### 按中位值排序  



原先的顺序无规律，不便于传达信息  

```{r}
 ggplot(d_Cd, aes(reorder(Scientific_Name, -Value, median), Value, color=Matrix))+
  geom_point()+
  scale_y_log10()+
  theme(axis.text.x = element_text(angle=20, hjust=1))
```



### 按中位值排序  

- 用到了`reorder()`函数按照中位数降序排列，你可以`reorder()`看看这个函数的用法，思考：按照均值升序如何排列？

- 还有另外一种更容易理解的手动排序方法，即从图上观察高低顺序，然后按顺序排列。这种方法很常用。代码如下：  

```{r}
d_Cd$Scientific_Name <- factor(
  d_Cd$Scientific_Name,
  levels = c(
    "Mytilus species",
    "Crassostrea virginica",
    "Mytilus edulis",
    "Geukensia demissa",
    "Ostrea sandvicensis",
    "Crassostrea rhizophorae"))

```

### 修饰细节  
- 数据点较多时，可以用小提琴图展现数据的分布，用抖动点充分展现原始数据
- 颜色的使用考虑色盲读者，考虑黑白打印     

```{r}
library(ggbeeswarm) #作蜂群图需要
ggplot(d_Cd, aes(reorder(Scientific_Name, -Value, median), Value, color=Matrix))+
  theme_bw()+
 geom_violin(draw_quantiles = 0.5)+ #小提琴图
 #geom_beeswarm(cex = 0.4, shape = ".", size = 3, alpha = 0.5)+ #蜂群图
  geom_jitter(shape=".", width = 0.2)+
  scale_y_log10()+ 
 annotation_logticks(sides="l")+ #对数刻度
  labs(x=NULL,
       y=expression("Cd concentration ("*mu*g~g^"-1"*"dry wt.)"),
       color=NULL)+
  theme(axis.text.x=element_text(face="italic", angle=20, hjust=1))+ #x轴斜体，转角
  theme(legend.position=c(1,1),
        legend.justification = c(1,1),
        legend.background = element_blank(),
        legend.key = element_blank())+ #调整图例位置、背景
  theme(panel.grid.minor = element_blank())+ #去掉次要网格
 scale_color_viridis_d(begin=0, end=0.6) #颜色选择，色盲友好
```



问题1得到回答了吗？


###汇总：把数据整理和画图的全部操作串联
```{r}
d0 %>%
    select(Fiscal_Year, Matrix, Scientific_Name, Parameter, Value, Unit) %>%
    filter(Matrix %in% c("Oyster", "Mussel")) %>%
    filter(Parameter == "Cadmium") %>%  
    filter(Scientific_Name != "Crassostrea gigas") %>% 
   ggplot(aes(reorder(Scientific_Name, -Value, median), Value, color=Matrix))+ #注意这步，省略了data指定，默认使用上游输送来的数据
    theme_bw()+
    geom_violin(draw_quantiles = 0.5)+ #小提琴图
    #geom_beeswarm(cex = 0.4, shape = ".", size = 3, alpha = 0.5)+ #蜂群图
    scale_y_log10()+ 
    annotation_logticks(sides="l")+ #对数刻度
    labs(x=NULL,
         y=expression("Cd concentration ("*mu*g~g^"-1"*"dry wt.)"),
         color=NULL)+
    theme(axis.text.x=element_text(face="italic", angle=20, hjust=1))+ #x轴斜体，转角
    theme(legend.position=c(1,1),
          legend.justification = c(1,1),
          legend.background = element_blank(),
          legend.key = element_blank())+ #调整图例位置、背景
    theme(panel.grid.minor = element_blank())+ #去掉次要网格
    scale_color_viridis_d(begin=0, end=0.6) #颜色选择，色盲友好  
```



## 用`group_by`和`summarise`分组计算均值、标准差  

- 按物种名（`Scientific_Name`）分组，计算浓度（`Value`）的均值（`mean`）和标准差（`sd`）
```{r warning=FALSE}
d_Cd_mean <-  d_Cd %>%
  group_by(Scientific_Name) %>% #<<
  summarise(mean = mean(Value), sd = sd(Value)) #<<

```
--

- 查看计算结果 

```{r}
d_Cd_mean

```

- 以上结果可用于作图，也可用于表格



## 研究问题2：
### Zn浓度高的牡蛎，是否Cd浓度也高？  

- 再来观察数据
- `Sample_ID`可以作为样品配对的依据  

```{r}
names(d0)
```


### 整理数据

1. 选择这些列：`Sample_ID`, `Fiscal_Year`, `Matrix`, `Scientific_Name`, `Parameter`, `Value`, `Unit`  
1. 筛选出`Oyster`的数据  
1. 筛选出`Cadmium`和`Zinc`的数据  
1. 删去物种*`Crassostrea gigas`*的数据（只有两条数据，缺乏代表性）  

```{r}
d_oy_Cd.Zn <- d0 %>%
  select(Sample_ID,
         Fiscal_Year,
         Matrix,
         Scientific_Name,
         Parameter,
         Value,
         Unit) %>%
  filter(Matrix == "Oyster" &
      Parameter %in% c("Cadmium", "Zinc") &
      Scientific_Name != "Crassostrea gigas") 
```


### 查看整理好的数据  

- 有哪些列？
```{r}
names(d_oy_Cd.Zn)
```

- 测定了哪些污染物？
```{r}
unique(d_oy_Cd.Zn$Parameter)
```


### 把数据切分成`Cd`数据、`Zn`数据 

- 用`subset()`切出`Cd`的数据
```{r}
d_oy_Cd <- subset(d_oy_Cd.Zn, Parameter=="Cadmium")
dim(d_oy_Cd) # 1718条数据
```

- 用`subset()`切出`Zn`的数据
```{r}
d_oy_Zn <- subset(d_oy_Cd.Zn, Parameter=="Zinc")
dim(d_oy_Zn) # 也是1718条数据
```

<br>

两种金属的数据都是1718条，很可能是一一对应的。这需要一一核对两组数据的`Sample_ID`才能确定，那是很大的工作量。这种情况下，`join`系列函数就派上用场了。



### 运用`inner_join()`合并两套数据  

- 当两组数据的`Sample_ID`相同时，则合并在同一行  

```{r}
d_oy <-
  inner_join(d_oy_Cd,
             d_oy_Zn,
             by = "Sample_ID", 
             suffix = c(".Cd", ".Zn"))
```

- 查看一下数据, 还是1718列，1个也没丢失，说明两组数据确实一一对应
```{r}
dim(d_oy)  
names(d_oy)
```



### `join`系列函数  


- `inner_join()`  
return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.    

- `left_join()`  
return all rows from x, and all columns from x and y. Rows in x with no match in y will have NA values in the new columns. If there are multiple matches between x and y, all combinations of the matches are returned.  

- `right_join()`  
return all rows from y, and all columns from x and y. Rows in y with no match in x will have NA values in the new columns. If there are multiple matches between x and y, all combinations of the matches are returned.  
<br>
- `full_join()`  
return all rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing.  
<br>
阅读： https://dplyr.tidyverse.org/reference/join.html



### 作散点图初步了解数据


```{r}
ggplot(d_oy, aes(Value.Cd, Value.Zn))+
  geom_point()

```






### 使用双对数坐标  



```{r}
ggplot(d_oy, aes(Value.Cd, Value.Zn))+
  geom_point()+
 scale_x_log10()+
 scale_y_log10()

```

* 原始数据里有“0”值，取对数后产生负无穷大（-Inf）.作图时会产生警告信息，但不妨碍出图。在坐标轴上可以看到这些点，他们露出了一半。







### 按不同物种分面作图  




```{r}
ggplot(d_oy, aes(Value.Cd, Value.Zn))+
  geom_point()+
  scale_x_log10()+
  scale_y_log10()+
  facet_wrap(~Scientific_Name.Zn) # 用Scientific_Name.Cd也一样

```
- 大部分数据都是关于*Crassostrea virginica*这种牡蛎的  





### 添加拟合线，帮助判断趋势  


```{r}
ggplot(d_oy, aes(Value.Cd, Value.Zn))+
  geom_point()+
  scale_x_log10()+
  scale_y_log10()+
  facet_wrap(~Scientific_Name.Zn)+
  geom_smooth(method="lm")

```
- 大部分数据都是关于*Crassostrea virginica*这种牡蛎的  





### 美化一下 

```{r}

ggplot(d_oy, aes(Value.Cd, Value.Zn, color= Scientific_Name.Zn))+
    theme_bw()+
    geom_point(shape=16, size=1/3, alpha=0.5)+
    scale_x_log10()+
    scale_y_log10()+
    annotation_logticks(sides="bl")+
    facet_wrap(~Scientific_Name.Zn)+
    geom_smooth(method="lm", color="black")+
    labs(x=expression("Cd concentration ("*mu*g~g^"-1"*")"),
         y=expression("Zn concentration ("*mu*g~g^"-1"*")"))+
    guides(color="none")+
    theme(strip.text = element_text(face="italic"))+ #横幅上物种名用斜体
    scale_color_viridis_d(end=0.6)
    

```



### 成品



问题2得到回答了吗？



## 要点小结

函数 | 功能
-----------|-----------------
`fliter()`  | 根据其值筛选行
`select()`  | 根据其名筛选列
`arrange()` | 改变行的排序，从低到高排
`arrange(desc())`| … 从高到低排
`mutate()`  | 基于现有变量进行计算，增加新的变量（类比excel里的C1=A1*B1)
`summarize()`  | 计算统计量（如均值、方差、中位数）
`pivot_longer()` | 宽数据变长数据
`pivot_wider()` | 长数据变宽数据
`melt()` |宽数据变长数据
`left_join()` |合并数据，保留左侧全部的，右侧没有对应值的则填充NA
`inner_join()` |合并数据，保留共有的
...      | ....




## 要点小结

### "`%>%`"运算符  

- 读作pipe，可以翻译成管道（很形象）  
- pipe将多个操作串联起来，上一操作的结果成为下一操作的对象  
- 功能类似`ggplot`里的"`+`"号  



## 练习

1. 分析不同年份贻贝的Cu浓度，看看有何趋势？
1. 自己观察数据，提出问题，并通过数据分析去回答。





## 阅读：

1. Overview of dplyr
https://dplyr.tidyverse.org/index.html


1. Introduction to dplyr
https://dplyr.tidyverse.org/articles/dplyr.html


<!--chapter:end:03-dplyr.Rmd-->

# `lubridate`处理时间数据



 加载程序包
```{r message=F, warning=F}
library(tidyverse) #作图
library(readxl) #读取excel文件
library(lubridate) #处理时间数据
```

## 时间格式转化  

### 字符串转化为日期（`Date`）格式   


```{r}
a <- "20220318" # a是字符格式
class(a)
b <- ymd(a) #将a转化为日期格式
class(b)

# ymd，ydm，mdy，myd等系列函数，`?ymd`查看  
mdy("03/18/2022") 
```



**日期格式自由，均能正确转化**  
```{r}
ymd("2022/03/18")

x <- c(20090101, "2009-01-02", "2009 01 03", "2009-1-4", "2009-1, 5", "Created on 2009 1 6", "200901 !!! 07")
ymd(x)
```


### 字符串转化为日期（`Date`）格式  
以下两个函数对输入格式有较严格要求
```{r }
as.Date("2022-03-12")  # 分隔号-
as.Date("2022/12/03") #分隔号/

date("2022-03-18") # 分隔号-

date("2022/03/18") #分隔号/

```


### 字符串转化为日期-时间（`date-time`）格式

```{r}
ymd_hms("2011-06-05 12:00:00") #年月日 时分秒
ymd_hm("2011-06-05 12:23") #年月日 时分；秒自动设置为0
ymd_h("2011-06-05 12") #年月日 时；分秒自动设置为0
```




## 时间信息提取  
  


### 提取日期数据中的信息   


```{r}
today() #今天的日期 
x <- today() 

year(x) # 哪年？
month(x) #哪月？
day(x) #哪日？
```



```{r}
wday(x) #一个星期中的第几天？（默认星期天为第1天）
wday(x, week_start = 1) #一个星期中的第几天？以星期一为第1天
```


## 提取日期-时间数据中的信息  


```{r}
now() #现在时刻

Sys.time() #电脑系统的现在时刻
y <- now()
hour(y) #几时？
minute(y) #几分？

```


```{r}
second(y)  #几秒？
wday(y, week_start = 1, label = T ) #星期几？（文字表示）
yday(y) #一年中的第几天？
week(y) #一年中的第几个星期？
```



## 时区  

关于时区设置：`?locales`查询  
关于时区名称，查看维基百科：
https://en.wikipedia.org/wiki/List_of_tz_database_time_zones  

```{r}
Sys.timezone() #所在时区：亚洲/上海，即北京时间

OlsonNames() #查询所有时区名称，该数据库由David Olson创立
```



## 时区  

```{r}
ymd_hms(now(), tz = "PRC") #将时间信息的时区设置为中国
with_tz(now(), tz="Europe/Berlin") #查看其他时区对应的时间，例如柏林

```



## 时间计算  



```{r}
now() #现在时间 

end <- paste(today(), "23:59:59") #今天的最后1秒
class(end) #是字符串，不是时间格式
end <- ymd_hms(end) #转化为时间格式
#今天还剩下多少时间  
end - now() # 计算两点间的时间长度；有误，时区不同导致


```


```{r}
end <- ymd_hms(end, tz="PRC") #时区设置为中国
end - now() #计算两点间的时间长度；正确
difftime(end, now()) #另一种方法，计算两点间的时间长度

today()-ymd(19820704) #我出生多少天了

```

  
## 时间数据可视化  



### 厦门空气质量数据分析  

数据来源：https://quotsoft.net/air/   
已下载并整理出厦门2018-2021四年的空气质量数据（csv格式）。

**读取并查看数据：**   
```{r}
d2021 <- read.csv("data/xiamen air/xiamen_air_2021.csv") #读取2021年的数据
names(d2021) #包含PM2.5，PM10，NO2，SO2， O3， CO等污染物，以及日期、小时、AQI等信息
```



### 2021年厦门PM2.5逐日变化趋势  
```{r}
d2021 %>%
  mutate(date = ymd(date)) %>%  #将date转化为日期格式（原为字符格式）
  ggplot(aes(date, PM2.5)) +
  geom_point()+ #所有点，每个小时1个点
  stat_summary(geom="line", fun="mean", color="red") #日均值线
  

```

 
 
### 2021年厦门PM2.5逐日变化趋势：调整细节  

```{r}
d2021 %>%
  mutate(date = ymd(date)) %>% 
  ggplot(aes(date, PM2.5)) +
  theme_classic()+
  geom_point(size=0.3, alpha=0.7, color="grey")+
  stat_summary(geom="line", fun="mean", color="red2")+ 
 scale_x_date(date_labels = "%m/%d", breaks = "1 month")+ 
#x轴时间格式设置，格式设置更多选择，查看?strptime(见下下页)
  labs(x = "Date",
       y = ~PM[2.5]~'('*mu*g~m^'-3'*')',
       title = "Xiamen, 2021")

```



## `?strptime`查看日期时间格式 

以下摘录部分，替换进.red[`scale_x_date(date_labels = "%x")`]试试以下代码的效果：  

%b
Abbreviated month name in the current locale on this platform. (Also matches full name on input: in some locales there are no abbreviations of names.) .red[月份文字缩写]

%B
Full month name in the current locale. (Also matches abbreviated name on input.) .red[月份文字全称]

%d
Day of the month as decimal number (01–31).

%D
Date format such as %m/%d/%y: the C99 standard says it should be that exact format (but not all OSes comply). .red[MM/DD/YY格式]

%F
Equivalent to %Y-%m-%d (the ISO 8601 date format).

%m
Month as decimal number (01–12). .red[月份，两位数表示]

%x
Date. Locale-specific on output, "%y/%m/%d" on input.




查看`?strptime`页面信息或上一页节选信息，尝试各种格式   



```{r}
format(today(), format = "%Y-%B-%d")
format(today(), format = "%Y/%b/%d")
format(today(), format = "%x")
format(today(), format = "%F")
```

```{r}
format(today(), format = "%m-%d")
format(today(), format = "%D")
```


## 合并四年数据用于分析  

```{r}
d2018 <- read.csv("data/xiamen air/xiamen_air_2018.csv")
d2019 <- read.csv("data/xiamen air/xiamen_air_2019.csv")
d2020 <- read.csv("data/xiamen air/xiamen_air_2020.csv")
d2021 <- read.csv("data/xiamen air/xiamen_air_2021.csv")

d0 <- rbind(d2018, d2019, d2020, d2021)
dim(d0) #34330条数据；(4年应该有365.25*24*4 = 35064条，说明缺失几天数据）
```



### 了解合并数据的结构，尤其是数据类型  
```{r}
str(d0)
```


## 数据整理  
目前存在问题：（1）`date`还不是日期格式；（2）没有完整的日期时间列

```{r}
d <- d0 %>% 
  mutate(time_ymdh = ymd_h(paste(date, hour))) #用ymd_h生成“年月日时”列

sample(d$time_ymdh, 10) #随机选10个查看，确认已是时间格式
class(d$time_ymdh) #查看格式，确认是时间格式

```

POSIXct = Portable Operating System Interface for Unix calendar time


Portable Operating System Interface for Unix calendar time


## 缺哪天的数据？  
用数据可视化的方式，快速找出缺失数据的位置
```{r}

d %>% 
  mutate(year = year(time_ymdh), #生成年列
         month = month(time_ymdh), #生成月份列
         day = day(time_ymdh)) %>%  #生成日列
ggplot(aes(x = day, y = month, z = PM2.5))+
  geom_raster(alpha = 0.5,fill = "blue")+ #作栅格图，找到缺失格
  facet_wrap(~year)+
  scale_x_continuous(breaks = 1:31)+
  scale_y_continuous(breaks = 1:12)+
  theme(panel.grid.minor = element_blank())

```


缺2018年12月22-26日和2019年8月24日数据。  
可从其他渠道获取数据，将缺失数据补齐。我们暂且忽略缺失数据，继续分析。  




## 总体趋势：厦门AQI的4年趋势
```{r}
d %>% 
  ggplot(aes(time_ymdh, AQI))+ #time_ymdh是日期时间格式，可作为x变量
  geom_line()+
  geom_smooth(se=F) #去除置信区间阴影


```

总体稳定在50上下，能看到明显的季节波动，空气质量优的天数在增加，污染的天数明显减少。  
注：AQI = 0-50是优，51-100是良，101-150是轻度污染，151-200是中度污染，201-300是重度污染，300+是严重污染



## 总体趋势：一并查看6项指标  
```{r}
d %>% 
  select(time_ymdh, PM2.5, PM10, SO2, NO2, O3, CO) %>%  #选出6项指标
  pivot_longer(cols=2:7, names_to = "parameter", values_to = "value") %>%  #将宽表格转为长表格，要转的数据在2-7列
  ggplot(aes(time_ymdh, value))+
  geom_line()+
  facet_wrap(~parameter, scales="free_y")+
  geom_smooth(se=F)


```



（1）CO、NO2、PM10、PM2.5、SO2浓度总体下降，极端值频率降低；（2）O3总体稳定；（3）季节波动明显



## 细看季节趋势：PM2.5  
将4年数据分开看，计算每日PM2.5均值，查看PM2.5均值在一年中的逐日变化趋势。  

```{r}
d %>% 
  mutate(year = year(time_ymdh), #新增列：年份
         time_d = yday(time_ymdh)) %>% #新增列：一年中的第几天
  group_by(year, time_d) %>%  #按某年的某日分组
  summarise(mean = mean(PM2.5, na.rm = T)) %>%  #计算PM2.5均值，注意去除缺失值
  ggplot(aes(time_d, mean, color=factor(year)))+
  geom_line()+
  facet_wrap(~year)+
  geom_smooth(se=F)+
  guides(color="none") #去除多余的颜色图例


```



可以看到：PM2.5在冬春季节较高，夏秋季节较低，第200天左右（即7月份）达到最低值。    


尝试一下：把PM2.5换成其他参数


## 细看各个月份：各月份的PM2.5概率密度分布    
```{r}

d %>% 
  mutate(month=month(time_ymdh)) %>% 
  ggplot(aes(x=PM2.5))+
  theme_bw()+
  geom_density(aes(color=factor(month))) #概率密度图，颜色映射到月份

```


各月份有明显区别，但混在一起，较难分辨  



## 对比各月份与总体的PM2.5概率密度分布   

```{r}
label_month <- month.name # month.name是12个月份的名称，敲一下看看
names(label_month) <- as.character(1:12) #用于将1-12月修改为January-December

d %>% 
  mutate(month=month(time_ymdh)) %>% 
  ggplot(aes(x=PM2.5))+
  theme_bw()+
  facet_wrap(~month,labeller = labeller(month = label_month))+
  geom_density(data=d, fill="grey80", alpha=0.3)+ #所有月份的数据（d中不含month列，不会被分面）
  geom_density(fill="red", color="red", alpha=0.2)+ #单独各个月份的数据（含month列，会被分面）
  labs(x=~PM[2.5]~'('*mu*g~m^'-3'*')',
       y="Probability density")
       
```


## 对比各月份与总体的PM2.5概率密度分布  
PM2.5浓度概率密度分布：黑色是总体的分布，红色是各个月份的分布  
往右拖尾表示污染升高，可以看到6-8月PM2.5明显低于总体均值  



## 季节趋势：总览全部参数  
```{r}
d %>% 
  select(time_ymdh, PM2.5, PM10, SO2, NO2, O3, CO) %>% 
  mutate(year = year(time_ymdh),
         time_d = yday(time_ymdh)) %>% 
  pivot_longer(cols=2:7, names_to = "parameter", values_to = "value") %>% 
  ggplot(aes(time_d, value, color=factor(year)))+
  geom_line(alpha=0.4)+
  facet_grid(parameter~year, scales="free")+
  geom_smooth(se=F)+
  guides(color="none")

```


## 工作日-周末趋势：PM2.5   

```{r}
d %>% 
  mutate(weekday = wday(time_ymdh, week_start = 1),
         month=month(time_ymdh)) %>% 
  group_by(weekday) %>% 
  summarise(mean = mean(PM2.5, na.rm=T),
            sd=sd(PM2.5, na.rm=T)) %>% 
  ggplot(aes(weekday, mean))+
  geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), fill="grey70")+ #条带上下限分别是mean+-sd
  geom_line()+
  geom_point()+
  scale_x_continuous(breaks=1:7)

```


周末和工作日PM2.5没有明显区别，周五PM2.5可能略低  


## 昼夜趋势：臭氧  

```{r}
d %>% 
  select(time_ymdh, PM2.5, PM10, SO2, NO2, O3, CO) %>% 
  mutate(year = year(time_ymdh),
         time_d = yday(time_ymdh),
         time_h = hour(time_ymdh)) %>% 
  ggplot(aes(time_h, O3, group=time_d))+ #用group将每天的数据分组，每天单独画一条线
  geom_line(alpha=0.1, color="red2")+
  facet_wrap(~year)

```


## 昼夜趋势：臭氧  

臭氧浓度有明显的昼夜变化趋势，上午10点后上升，15点左右达到最高值。  


```{r}
#计算整体的各小时均值（不区分月份）
d_all <- d %>% 
 mutate(time_h = hour(time_ymdh)) %>% 
 group_by(time_h) %>% 
 summarise(mean= mean(O3, na.rm=T)) 


d %>% 
  mutate(year = year(time_ymdh),
         time_h = hour(time_ymdh),
         time_mt = month(time_ymdh)) %>% 
  group_by(time_mt, time_h) %>% #按月份计算各小时均值
  summarise(mean= mean(O3, na.rm=T)) %>% 
  ggplot(aes(time_h, mean))+
  geom_line(color="red2")+ #红线表示各月份的小时均值
  geom_line(data=d_all, aes(time_h, mean), inherit.aes=F, color="grey50")+ #灰线表示总体均值
  facet_wrap(~time_mt)


```


## 昼夜趋势：臭氧  
红线：各月份均值；灰线：总体均值  
各月份之间存在区别：例如1月份O3浓度低，峰值出现时间晚；6-7月份O3浓度低，峰值出现时间早；9-10月份O3浓度高，峰值出现时间与总体均值类似。  


---
## 要点小结  

操作                |函数
--------------------|---------------------
将字符转化为时间    |`ymd()`系列   
                    |`ymd_hms()`系列   
提取时间信息        |`year()`-年；`month()`-月；`day()`-日
                    |`hour()`-时；`minute()`-分；`second()`-秒
                    |第几天：`yday()`-年；`mday()`-月；`wday()`-星期
坐标轴时间格式设置  |`scale_x_date()`
                    |`scale_x_datetime()`


---
## 拓展阅读  

https://lubridate.tidyverse.org/

https://r4ds.had.co.nz/dates-and-times.html



<!--chapter:end:04-lubridate.Rmd-->

# 绘制地图

We have finished a nice book.

<!--chapter:end:05-map.Rmd-->

# 相关性分析

Here is a review of existing methods.

<!--chapter:end:06-correlation.Rmd-->

# 线性回归

Here is a review of existing methods.

<!--chapter:end:07-mlr.Rmd-->

# Logistic回归

Here is a review of existing methods.

<!--chapter:end:08-logistic.Rmd-->

# *t*检验

Here is a review of existing methods.

<!--chapter:end:09-ttest.Rmd-->

# 单因素方差分析

Here is a review of existing methods.

<!--chapter:end:10-anova.Rmd-->

# 多因素方差分析

Here is a review of existing methods.

<!--chapter:end:11-2wayanova.Rmd-->

# 协方差分析

Here is a review of existing methods.

<!--chapter:end:12-ancova.Rmd-->

# 主成分分析

Here is a review of existing methods.

<!--chapter:end:13-pca.Rmd-->

`r if (knitr:::is_html_output()) '
# References {-}
'`

<!--chapter:end:14-reference.Rmd-->

