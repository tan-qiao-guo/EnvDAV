--- 
title: "环境数据分析与可视化"
author: "谭巧国"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
split_by: section
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: rstudio/bookdown-demo
description: "厦门大学环境与生态学院研究生课程"
---

# 前言 {-}

本网站内容用于厦门大学环境与生态学院研究生课程“环境数据分析与可视化”的教学。内容在持续更新中。



```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# R的基础知识 {#intro}

## 科学计算器

四则运算：
```{r comment='#'}
(1 + 2 * 4)/3 - 1.3
```

指数运算：
例如，100的0.5次方：
```{r comment='#'}
100^0.5
```

对数运算：
```{r comment='#'}
log(2)
```
注意这是自然对数，与excel里的表述不一样。若以10为底，需明确标注：
```{r comment='#'}
log10(2) 
```
类似地，以2为底的对数是：
```{r}
log2(2)
```

特殊的常数：
e是自然对数的底，e=2.718..., exp(1) = e^1；用于指数函数
```{r}
exp(1)
```

pi = 3.14159...圆周率
```{r}
sin(pi/2)
```

科学计数法，6.22*10^23，注意这里e不是自然对数的底
```{r}
6.22e23
```

绝对值
```{r}
abs(-10) 

```


### 取整  


`round()`函数取整原则：**四舍六入五成双**
```{r}
round(2.3)
round(2.6)
round(2.5)
round(3.5)

floor(2.6) #向下取整
ceiling(2.3) #向上取整
trunc(2.3)#取整数部分
trunc(2.6)

```




### 保留有效数字

原则：**四舍六入五成双**
```{r}
round(pi, 2) #保留2位小数
round(pi, 3) #保留3位小数

signif(pi,2) #保留2位有效数字
signif(pi,3) #保留3位有效数字
```




### 常用运算符

符号 | 含义
-----|-------------
+    | 加
-    |减
*    |乘
/    |除
^    |乘方
%/%  |商
%%   |余数
\>   |大于
\>=  |大于等于
=    |等于
<    |小于
<=   |小于等于
==   |等于
!=   |不等于
!    |非
&    |与
\||或
~    |前者是后者的函数
<-   |向左赋值 (可读作“得到”)
->   |向右赋值 (可读作“得到”)
$    |列表索引
:    |创建序列



\newpage

### 逻辑运算  


```{r}
5 > 3
5 == 3
1:5 != 3
```


```{r}
1:5 > 2 & 1:5 <5
1:5 <= 2 | 1:5 >=4

```


>注：`1：5`的是指包含“1，2，3，4，5”这5个自然数的向量



##  变量赋值

在R语言里，用符号".red[**`<-`**]"给变量赋值。它的功能和"**`=`**"几乎等同。但是用`<-`是一种传统，我们最好遵守。

```{r}
x1 = 12
x1

x2 <- 23
x2

y <- x1 + x2
y

x1 + x2 -> z 
z
```



##  变量取名规则  


* 变量名只能是字母、数字、点（`.`）、下划线（`_`）的组合

* 只能以字母或点开头；不能以数字、下划线开头

* 对字母大小写敏感，`a`和`A`是不同的变量
* 变量名不能含有空格：`x_1`, `x.1`都可以，但`x 1`不可以；推荐`x_1`形式的命名，理由是方便阅读，方便记忆



##  变量类型  

变量     | 含义
---------|-------------
integer  | 整数
numeric  | 实数
character| 字符
logical  | 逻辑值(`TRUE`或`FALSE`)



```{r}
class(as.integer(1.2)) #将1.2转化为整数,并查看其类型

```


```{r}

class(pi) # pi = 3.1415......
class("Xiamen")
```



```{r}
class(c(TRUE,FALSE))

```



##  常用的数据类型

数据类型  |    说明
----------|------------------------------------------
vector    | 向量，元素可以是数值、字符串、逻辑值
factor    | 因子，水平，是离散的，以整数vector形式储存，映射到字符串上
matrix    | 矩阵，所有元素的类型(numeric, character等)需一致
data frame| 数据表，和matrix类似，但每列的类型可以不一致
list      | 清单，与vector类似，但每个元素的类型可以不一致，且可以是任何数据类型（例如numeric,data frame, list...)




## 数据类型强制转化（`coercing`）


```{r}
t_1 <- c("1", "2", "3.4") #字符，无法进行计算
t_1
class(t_1)
t_2 <- as.numeric(t_1) #转化为数值，就可以计算了
t_2
class(t_2)
```



```{r}
t_3 <- as.factor(t_2) #数值转化为因子，非常有用的功能，以后详述
t_3
class(t_3)
```




## 缺失值（`NA`）和无穷大（`Inf`）

实验数据经常会有缺失值，缺失值的处理对于数据分析非常重要。
.pull-left[
```{r}
v0 <- c(1, 3, 4, NA) #第4个数缺失  
v0

is.na(v0) #判断是否有缺失值
v0[is.na(v0)] <- 0 #将缺失值替换为0
v0
```




```{r}
logv0 <- log(v0) #对数据进行自然对数转化，产生了负无穷大值（-Inf）
logv0
is.infinite(logv0) # 检查是否有无穷大，包括Inf和-Inf

logv0[is.infinite(logv0)] <- NA #将无穷大替换为缺失值NA
logv0

```




## 向量（vector）

### 用函数`c( )`生成向量
>"c"的含义:
>1. combine  
>2. concatenate [kɒn'kætɪneɪt] vt.把 （一系列事件、事情等）联系起来  


* **数值向量**  

```{r}
v1 <- c(1.4, 3, 10.9, -7)
v1
```

* **字符向量**  

```{r}
v2 <- c("apple","organge","banana")
v2
```




* **逻辑值向量**  

```{r}
v3 <- c(TRUE,FALSE,TRUE,FALSE)
v3
```





### 用 `seq()`生成等差序列  

```{r sequence}
seq(from = 10, to = 100, by = 10) 

```

from是第一个值，to是最后一个值，by是相邻两个数的间隔值。  
可以简略成(默认第1个数赋给`from`，第2个数赋给`to`，第3个数赋给`by`) :
```{r}
seq(10, 100, 10)

```


怎么使用`seq()`函数？--查看帮助信息。

执行代码`?seq`， 你会在Help栏看到如下信息:

> Usage  
>seq(...)  
>Default S3 method:  
>seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
>    length.out = NULL, along.with = NULL, ...)  


  
耐心读一读，你可以看懂。读懂之后，你还可以这么使用`seq()`：

```{r}
seq(10, 100, length.out = 19)
```
`length.out`是数列的长度

```{r}
v2 <- seq(10, 100, length.out = 19)
v2[12]
```



### 用`:`符号生成连续自然数序列

```{r}
1:10
v3 <- 20:30
v3
```



### 用**`rep()`**重复元素，生成向量

```{r}
rep(8, 5)
rep("ha", 6)
```



 
```{r}
rep(1:3, 2)
rep(1:3, each = 3)
rep(1:3, each = 3, times=2)

```


这个功能在自动填充数据表s时非常有用，例如，填充treatment，replicate编号。


### 向量信息提取与运算  
```{r message = F, error = T}
v1 <- c(1.4, 3, 10.9, -7)
v1[3] # 引用第3个元素
v1 + 10 # 每个元素均加10
v1 * 10 # 每个元素均乘以10
v1^2 #每个元素均求平方
```




### 针对向量的统计运算


```{r }
v4 <- seq(60, 100, 5)
v4
summary(v4) 
mean(v4) #算术平均值
median(v4) #中位数

```



```{r}
sd(v4) # 标准差
min(v4) # 最小值
max(v4) # 最大值
range(v4) #范围：最小值～最大值
```




## 矩阵（matrix）

### 用`matrix()`函数生成一个矩阵

```{r}
m1 <- matrix(1:18, nrow=3, ncol=6)
m1

```

默认按列排元素，可用`byrow`更改为按行排
```{r}
m2 <- matrix(1:18, nrow=3, ncol=6, byrow=T)
m2
```



## 数据表（data frame）

### 用`data.frame()`函数生成一个数据表

数据表储存以下信息：学生姓名、性别、考试分数
```{r}
student <- c("Tom", "Jack", "Mingming", "Alice", "Feifei")
sex <- c("Male", "Male", "Male", "Female", "Female")
score <- c(83, 72, 80, 92, 95)

data.frame(student, sex, score)

```



可将该数据表储存于变量**`d1`**中，也可以说给数据表取个名字叫**`d1`**
```{r}
d1 <- data.frame(student, sex, score)
```




### 引用`data.frame`中的信息  

引用**`d1`**数据表的**`student`**列有两种方法，一种是用名称，一种是用编号：
```{r}
d1$student 

d1[ , 1] #逗号前是行号，逗号后是列号

```

--
引用**`d1`**数据表第2个学生的成绩有两种方法，一种是用名称，一种是用编号:
```{r}
d1$score[2]
d1[2, 3] 
```



### 查看base R自带的数据

```{r}
data() #用此函数查看R自带的数据，以下是节选。
``` 
可以用这些数据来测试、交流你的统计、绘图代码。

数据名称 |简介
--------------|--------------------------
BOD           |Biochemical Oxygen Demand  
ChickWeight   |Weight versus age of chicks on different  
ToothGrowth   |The Effect of Vitamin C on Tooth Growth in Guinea Pigs
co2           |Mauna Loa Atmospheric CO2 Concentration
iris          |Edgar Anderson's Iris Data
mtcars        |Motor Trend Car Road Tests
npk           |Classical N, P, K Factorial Experiment
precip        |Annual Precipitation in US Cities
pressure      |Vapor Pressure of Mercury as a Function of Temperature
rivers        |Lengths of Major North American Rivers


---
  
### 查看数据表的常用命令
  
* 查看数据**`iris`**表头（默认前6行，可更改）  

```{r}
head(iris )
```

--
  
* 查看表尾（默认最后6行，可更改，此处改为4行）  

```{r}
tail(iris, 4)
```



* 查看数据表有哪些变量   

```{r}
names(iris) 
```
以上结果显示5个变量的名称，**每1列是1个变量**。



* 查看数据表的尺寸（dimension），即**行数**和**列数**
```{r}
dim(iris) 
```
结果显示150行，5列。



`length()`显示数据表的列数，即变量数；显示vector的长度，即元素数。
```{r}
length(iris) #5列
length(iris$Species) #150行
```





### 查看数据表的其他性质  

* **查看数据表的结构**
```{r}
str(iris)    

```
前4列均为**`numeric`**，最后一列为**`factor`**  




* **查看数据表的概要**

```{r}
summary(iris)
```
包含了每列的最小值、25%分位数、中位值、均值、75%分位数、最大值



* **查看`iris`这个对象（object）的类型**  

```{r}
class(iris) 
```
当然是**data.frame**类型。



### 合并数据表

```{r}
d1
```



```{r}
d2 <- data.frame(age = c(20, 19, 20, 21, 19))
d2
```




* 合并列（**`column binding`**）
```{r}
cbind(d1, d2) 
```




* 合并行（**`row binding`**）
```{r}
rbind(d1, d1)
```




## 读入数据

四种方法：

代码 | 说明
-----|----------------------------
`d1 <- read.table("clipboard", head = T)` | 从剪贴板（ctrl+C）直接读取，适合于小数据表的快速操作
`d2 <- read.csv(file.choose())` | 弹出对话框，点击鼠标选取文件，读取`csv`格式的数据
`d3 <- read.csv("你的文件名.csv")` |从工作目录下直接读取`csv`格式的数据
`d4 <- read_excel("你的文件名.xlsx", sheet = 1)` | 直接读取`xlsx`文件中某个sheet（此处为sheet1）中的数据，需先加载`readxl`程序包




##  输出数据

`co2`是R自带的时间序列数据，此处将其转化为`data.frame`，用**`write.csv()`**函数将数据储存于名为“CO2_data.csv”的文件中。你可在工作文件夹下找到该文件。 
```{r error=TRUE}
d_CO2 <- data.frame(time = time(co2), CO2 = co2) 

write.csv(d_CO2, "CO2_data.csv")

```



## Base R简单作图



### 默认的`plot()`函数  

绘制散点图，可用于快速了解数据。
```r 
plot(x = d_CO2$time, y = d_CO2$CO2)
```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2)
```
]

---

### 修改为折线图


```r
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l")
```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l")
```

---

### 修改颜色设置


```r 
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red")
```


.pull-right[
```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red")
```




### 修改坐标轴名称


```r 
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red", xlab = "Year", ylab = expression(pCO[2]~"(ppm)"))

```



```{r echo = FALSE, fig.width=8, fig.retina = 4}
plot(x = d_CO2$time, y = d_CO2$CO2, type = "l", col = "red", xlab = "Year", ylab = expression(pCO[2]~"(ppm)"))

```




## `ggplot`作图

先对`ggplot`绘图有个简单印象，下次课我们深入学习。


```{r}
library(ggplot2) #ggplot绘图
ggplot(d_CO2, aes(time, CO2))+
  theme_bw()+
  geom_line(color = "red2")+
  labs(x = "Year",
       y = ~pCO[2]~(ppm))

#ggsave("pCO2.png", width=342/90, height=243/90, dpi=600)
```









## 保存图片

### 第一种方法  
首先将图片赋值给变量**`p1`**。 

```r
library(ggplot2)

p1 <- ggplot(mpg, aes(displ, hwy))+
  geom_point()


然后调用**`png()`**作图设备作图，并记得随手用**`dev.off()`**关闭作图设备（否则不出图）。变量**`p1`**夹在以上两行代码之间。完成操作后，你就能在工作文件夹里找到名称为“myplot_1.png”的图了。

```r 
png("myplot_1.png", width=359/90*600, height=239/90*600, res=600)
p1
dev.off()
```




## 保存图片

### 第二种方法  

由于我们以后大多使用**`ggplot()`**作图，因此可以用**`ggplot2`**程序包中的**`ggsave()`**函数保存当前显示的图片（在RStudio右下面板中）。
```r 
library(ggplot2)
ggplot(mpg, aes(displ, hwy))+
  geom_point()

ggsave("myplot_2.png", width=359/90, height=239/90, dpi=600) #png格式，位图
ggsave("myplot_2.pdf", width=359/90, height=239/90) #pdf格式，矢量图
```
完成以上操作，你就能在工作文件夹里找到名称为“myplot_2.png”“myplot_2.pdf”的图了。

>如何设置合适的**`width`**和**`height`**?  
>需要一些技巧（我会操作演示）和审美能力。




---
## 推荐阅读
Crawley MJ. The R Book. 2nd ed. Chapter 2. Essentials of the R Language.pp 12-136.
(有点枯燥，至少读1/3，读不完的之后的学习过程中还可以再回过头读。)


<!--chapter:end:01-intro.Rmd-->

# `ggplot2`作图入门



### ggplot基本理念  

图层、映射  


展开画布，一张空图  
```{r}
library(ggplot2)

ggplot()
```


数据有了，但还不知道要画什么图，仍然是一张空图  
```{r}
ggplot(mpg)
```

知道了谁是`x`
```{r}
ggplot(mpg)+
  aes(x = displ)
```

知道了谁是`y`
```{r}
ggplot(mpg)+
  aes(x = displ)+
  aes(y = hwy)
```

知道了要画什么图，图就有了  
```{r}
ggplot(mpg)+
  aes(x = displ)+
  aes(y = hwy) +
  geom_point()
```


把`aes()`收进`ggplot()`，代码显得紧凑  
```{r}
ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point()
```

颜色映射到变量`class`，
```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = class))+
  geom_point()
```

颜色映射放在ggplot里，会管住所有图层    
```{r warning=FALSE}
ggplot(mpg, aes(x = displ, y = hwy, color = class))+
  geom_point()+
  geom_smooth()
```


颜色映射放在`geom_point()`里，只能管住`geom_point()`图层，对其他图层不起作用  
```{r warning=FALSE}
ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point(aes(color = class))
  

ggplot(mpg, aes(x = displ, y = hwy))+
  geom_point(aes(color = class))+
  geom_smooth()
```




## 以R自带的数据**`ToothGrowth`**为例
先用敲入代码**`?ToothGrowth`**来了解一下数据。
>The Effect of Vitamin C on Tooth Growth in Guinea Pigs (豚鼠)  
> Description  
> The response is the length of odontoblasts (cells responsible for tooth growth) in 60 guinea pigs. Each animal received one of three dose levels of vitamin C (0.5, 1, and 2 mg/day) by one of two delivery methods, orange juice or ascorbic acid (a form of vitamin C and coded as VC).  

> Format  
> A data frame with 60 observations on 3 variables.  

>[,1]	len	numeric	Tooth length  .red[第1列是数值变量，牙齿长度]  
>[,2]	supp	factor	Supplement type (VC or OJ) .red[第2列是因子，补充剂类型，维C还是橙汁]  
>[,3]	dose	numeric	Dose in milligrams/day  .red[第3列是数值变量，补充剂的剂量]  

> References
> Crampton, E. W. (1947). The growth of the odontoblast of the incisor teeth as a criterion of vitamin C intake of the guinea pig. The Journal of Nutrition, 33(5), 491–504. doi: 10.1093/jn/33.5.491.



---

##了解一下**`ToothGrowth`**的内容

先用**`head()`**来看看数据长什么样：

```{r}
head(ToothGrowth)
```
再用**`str()`**具体了解一下数据概况：
```{r}
str(ToothGrowth)
```

---

## 开始作图  

* 使用`ggplot()`作图，需先加载`ggplot2`程序包  
* 可以略去“`x=`”，“`y=`”，使代码更简洁；第1个数默认给x，第2个默认给y


```{r}
library(ggplot2) #加载ggplot2包

ggplot(ToothGrowth, aes(x=dose, y=len))+
  geom_point()
```


```{r}
#简洁代码：
ggplot(ToothGrowth, aes(dose, len))+
  geom_point()
  
```




## 用颜色"**`color=`**"区分不同处理  

* 将颜色（`color`）映射（mapping）到补充剂类别（`supp`）上，即用不同颜色区分“VC”和“橙汁”数据  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, color=supp))+
  geom_point()  
  
```





## 用形状"**`shape=`**"进一步区分不同处理

- 将点的形状映射到补充剂类别上，即用不同形状区分“VC”和“橙汁”数据    
- 黑白打印、色盲友好  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, color=supp,shape=supp))+
  geom_point()  
  
```



## 用"**`stat_summary()`**"添加平均值

- 我们喜欢看平均值  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  geom_point()+
  stat_summary(geom="line", fun="mean")
  
```
]





## 用"**`stat_summary()`**"添加平均值

- 去掉散点，加上平均值对应的点  


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
 #geom_point()+ #加上井号的作用：使这行代码变为注释，不运行
  stat_summary(geom="line", fun="mean")+
 stat_summary(geom="point", fun="mean")
  
```





---

## 用"**`stat_summary()`**"添加误差棒

- 计算标准差的函数是`sd()`；误差棒：`errorbar`


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x),          fun.max=function(x) mean(x)+sd(x)) #自定义函数计算标准差；还有很多其他方法，目前这个方法最容易理解
  
```





## 用"**`stat_summary()`**"添加误差棒

- 美化一下误差棒


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), width=0.1) #把误差棒变窄，试试改为0
  
```




 我的数据不是这种格式啊!  




```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
d_tooth <- ToothGrowth %>%
  group_by(supp, dose) %>%
  summarise(mean = mean(len), 
            sd = sd(len))

d_tooth$mean <- round(d_tooth$mean, 2)
d_tooth$sd <- round(d_tooth$sd, 2)

d_tooth_wide <- cbind(d_tooth[1:3,],d_tooth[4:6,])

```



```{r, echo=FALSE}

knitr::kable(d_tooth, format = "html")
```



##  甚至是这样的

```{r, echo=FALSE}
knitr::kable(d_tooth_wide, format = "html")

```



  ## 这样的数据不方便统计分析，.red[以后别这样了]

- 左边的长表格格式整齐，R可以直接处理，但缺点是丢失了原始信息
- 右边的宽表格R不能直接处理（可以转化，之后课程会讲）




## 这样才是好的格式，这叫.blue2[**Tidy Data**]

```{r eval=require('DT'),  echo=FALSE}
DT::datatable(
  ToothGrowth,
  fillContainer = FALSE, options = list(pageLength = 8)
)
```



## Tidy Data 整齐数据  

> ### Tidy data is data where:

> ### Each variable is in a column. .red[每1列对应1个变量]
> ### Each observation is a row. .red[每1行对应1个样本、1次观察]
> ### Each value is a cell. .red[每1格包含1个值]

.footnote[
[阅读材料：What is “Tidy Data”? https://www.r-bloggers.com/what-is-tidy-data](https://www.r-bloggers.com/what-is-tidy-data/)
]



### 修改细节，使之规范   


```{r}
ggplot(ToothGrowth, aes(x=dose, y=len, 
color=supp, shape=supp))+
  theme_bw()+ #使用黑白主题，默认的是灰色主题
  stat_summary(geom="line", fun="mean")+
  stat_summary(geom="point", fun="mean")+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), width=0.1)+
  labs(x="Dose (mg/day)", #x轴标签
      y="Tooth length (mm)", #y轴标签
      color="Supplement", #颜色标签
      shape="Supplement")+ #形状标签，与颜色的一致
  scale_y_continuous(limits=c(0, NA))+ #y轴取值范围
  theme(legend.position=c(0.8, 0.2), #图例的位置，左下角为(0,0),右上角为(1,1)
        legend.background = element_blank(), #使图例方框背景透明
        legend.key = element_blank()) #使图例符号背景透明
```



##`ggasve()`保存

- 保存下来的图片显示质量比预览的效果更好一些
```r
ggsave("tooth_1.png", width=280/90, height=224/90, dpi=600)
```

## 当然，用“均值+标准差”格式的数据也可以作图


将此数据命名为**`d_tooth`**  

```{r, echo=FALSE}

knitr::kable(d_tooth, format = "html")
```

- **`d_tooth`**可以通过以下代码得到：  

```{r}
library(dplyr)
d_tooth <- ToothGrowth %>%
  group_by(supp, dose) %>%
  summarise_at(vars(len), funs(mean, sd))
```



## 当然，用“均值+标注差”格式的数据也可以作图

- **用`geom_line()`画折线；`geom_errorbar()`画误差棒**


```{r}
 ggplot(d_tooth, aes(x=dose, y=mean, 
 color=supp, shape=supp))+
   theme_bw()+ 
   geom_point()+ #画点
   geom_line()+ #画线
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)+ #画误差棒，注意误差棒的上下限需用aes()映射到mean和sd上
   labs(x="Dose (mg/day)", 
        y="Tooth length (mm)", 
        color=NULL, #去掉了颜色标签
        shape=NULL)+ #去掉了形状标签
   scale_y_continuous(limits=c(0, NA))+ 
   theme(legend.position=c(0.8, 0.2), 
         legend.background = element_blank(), 
         legend.key = element_blank()) 
  
```




## 用`geom_col()`画柱状图
- 不要用`geom_bar()`画柱状图--不是不可以，只是不是按你想的那样


```{r}
ggplot(d_tooth, aes(x=dose, y=mean, color=supp))+
   geom_col()+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)

```



这不是我们想要的



### 柱子的颜色用**`fill`**，柱子的边框才是**`color`**
### 若有多组柱子，需要`dodge`让他们错开，否则默认`stack`堆叠


```{r}
ggplot(d_tooth, aes(x=dose, y=mean,  fill=supp))+
  geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1)

```


 

### 用**`position = position_dodge()`**，错开多组误差棒


```{r}
ggplot(d_tooth, aes(x=dose, y=mean, fill=supp))+
   geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1,
                 position=position_dodge(width=0.45))

```
 


### 把x轴的`dose`变为`factor`类型，使柱子之间等间隔


```{r}
  ggplot(d_tooth, aes(x=factor(dose), y=mean, fill=supp))+
   geom_col(position="dodge")+
   geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.1,
                  position=position_dodge(width=0.9)) #注意width也改为0.9，这个可以试错出来

```
 

## 修改细节，使之规范  


```{r}
ggplot(d_tooth, aes(x=factor(dose), y=mean, fill=supp))+
  theme_bw()+
  geom_col(position="dodge", width = 0.7)+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd, color=supp), width=0.1, position=position_dodge(width=0.7))+
  labs(x=expression("Dose (mg"~d^"-1"*")"),
       y="Tooth length (mm)",
       fill=NULL, color=NULL)+
  theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())
```


##柱状图完成，`ggasve()`保存

- 除了默认的颜色土一点，基本达到发表的要求了（颜色以后我们专题讨论）

```r
ggsave("tooth_2.png", width=316/90, height=232/90, dpi=600)
```


## 直接用`Tidy Data`（`ToothGrowth`）作柱状图 


```{r}
ggplot(ToothGrowth, aes(x=factor(dose), y=len, fill=supp))+
  theme_bw()+
  stat_summary(geom="col", fun="mean", position="dodge", width = 0.7)+
  stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x), aes(color=supp), width=0.1, position=position_dodge(width=0.7))+
  labs(x=expression("Dose (mg"~d^"-1"*")"),
       y="Tooth length (mm)",
       fill=NULL, color=NULL)+
  theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())
```




## 用`geom_boxplot()`画箱式图  


```{r}
ggplot(ToothGrowth, aes(dose, len,  color=supp))+
 geom_boxplot()

```




- **问题出在哪：`dose`是连续变量（`numeric`格式），不适合boxplot，需先转化为`factor`**




## 用`factor()`将数值变量转化为因子  


```{r}
 ggplot(ToothGrowth, aes(factor(dose), len,  color=supp))+
  geom_boxplot()

```





##修饰细节，使之规范   


```{r}
ggplot(ToothGrowth, aes(factor(dose), len,  color=supp))+
   theme_bw()+
geom_boxplot()+
    labs(x=expression("Dose (mg"~d^"-1"*")"),
        y="Tooth length (mm)", color=NULL)+
   theme(legend.position=c(0.1, 0.86),
        legend.background = element_blank(),
        legend.key = element_blank())

```






---

## 要点小结


图         | 函数
-----------|--------------------
点         |`geom_point()`
线         |`geom_line()`
柱         |`geom_col()`推荐； `geom_bar()`
箱         |`geom_boxplot()`
误差棒     |`geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd))`
统计-误差棒| `stat_summary(geom="errorbar", fun.min=function(x) mean(x)-sd(x), fun.max=function(x) mean(x)+sd(x))`
统计-均值点|`stat_summary(geom="point", fun="mean")`
统计-均值线|`stat_summary(geom="line", fun="mean")`

---

## 阅读作业  

### Hadley Wickham. 2016. ggplot2 Elegant Graphics for Data Analysis.
- .large2[Chapter 2. Getting Started with ggplot. pp. 11-32]
- .large2[Chapter 3. Toolbox. pp. 33-74]

<!--chapter:end:02-ggplot.Rmd-->

# 数据整理

We describe our methods in this chapter.

Math can be added in body using usual syntax like this 

## math example

$p$ is unknown but expected to be around 1/3. Standard error will be approximated

$$
SE = \sqrt(\frac{p(1-p)}{n}) \approx \sqrt{\frac{1/3 (1 - 1/3)} {300}} = 0.027
$$

You can also use math in footnotes like this^[where we mention $p = \frac{a}{b}$].

We will approximate standard error to 0.027[^longnote]

[^longnote]: $p$ is unknown but expected to be around 1/3. Standard error will be approximated

    $$
    SE = \sqrt(\frac{p(1-p)}{n}) \approx \sqrt{\frac{1/3 (1 - 1/3)} {300}} = 0.027
    $$

<!--chapter:end:03-dplyr.Rmd-->

# `lubridate`处理时间数据

Some _significant_ applications are demonstrated in this chapter.

## Example one

## Example two

<!--chapter:end:04-lubridate.Rmd-->

# 绘制地图

We have finished a nice book.

<!--chapter:end:05-map.Rmd-->

# 相关性分析

Here is a review of existing methods.

<!--chapter:end:06-correlation.Rmd-->

# 线性回归

Here is a review of existing methods.

<!--chapter:end:07-mlr.Rmd-->

# Logistic回归

Here is a review of existing methods.

<!--chapter:end:08-logistic.Rmd-->

# *t*检验

Here is a review of existing methods.

<!--chapter:end:09-ttest.Rmd-->

# 单因素方差分析

Here is a review of existing methods.

<!--chapter:end:10-anova.Rmd-->

# 多因素方差分析

Here is a review of existing methods.

<!--chapter:end:11-2wayanova.Rmd-->

# 协方差分析

Here is a review of existing methods.

<!--chapter:end:12-ancova.Rmd-->

# 主成分分析

Here is a review of existing methods.

<!--chapter:end:13-pca.Rmd-->

`r if (knitr:::is_html_output()) '
# References {-}
'`

<!--chapter:end:14-reference.Rmd-->

